<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空博客</title>
  
  <subtitle>总不能浪费个副标题吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-04T14:29:42.179Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JQK/许阳航</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>宏与头文件</title>
    <link href="http://yoursite.com/2020/05/04/%E5%AE%8F%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/05/04/宏与头文件/</id>
    <published>2020-05-04T13:49:08.000Z</published>
    <updated>2020-05-04T14:29:42.179Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/04/YPKBxs.jpg" alt="YPKBxs.jpg"></p><a id="more"></a><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><code>#define</code>用来定义一个宏。</p><p><code>#</code>开头的是编译预处理指令。</p><p>在c语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的宏的名字替换成值。</p><p>宏的定义可以做到非常复杂。</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="多个-c文件"><a href="#多个-c文件" class="headerlink" title="多个.c文件"></a>多个.c文件</h2><p>在一个项目中的多个<code>.c</code>文件是可以一起编译，然后链接起来的，通常<code>.c</code>文件中存放的都是函数。</p><p>如果你在一个<code>.c</code>文件中使用了另一个文件中定义的函数，没有函数声明，又恰好用了不同数据类型的参数，在链接的时候是不会发生错误的。</p><p>因此通常我们需要一个<code>.h</code>文件来存放函数声明和全局变量。</p><h3 id="从-c到可执行文件"><a href="#从-c到可执行文件" class="headerlink" title="从.c到可执行文件"></a>从.c到可执行文件</h3><p><code>.c</code>—&gt;<code>.i</code>—&gt;<code>.s</code>—&gt;<code>.o</code>—&gt;<code>.out</code></p><ul><li><code>.c</code>：源代码文件</li><li><code>.i</code>：编译预处理文件</li><li><code>.s</code>：汇编代码文件</li><li><code>.o</code>：经过汇编得到目标代码文件</li><li><code>.out</code>：经过链接等操作得到可执行文件</li></ul><h2 id="头文件-h"><a href="#头文件-h" class="headerlink" title="头文件.h"></a>头文件.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这行代码很眼熟吧，这里需要注意两点：</p><ul><li>有时候我们会说引入了库函数，这种说法是有失偏颇的，<code>stdio.h</code>中都是函数声明，实际上并没有函数定义</li><li><code>&lt;&gt;</code>表示到指定目录下去寻找该头文件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MAX.h"</span></span></span><br></pre></td></tr></table></figure><p>我们自己定义的头文件，用<code>&quot; &quot;</code>，表示在同一个项目的文件中寻找</p><p>头文件实际上也是<strong>文本替换</strong>。这就会导致多个文件之间相互<code>include</code>时，有极大可能会发生重定义(redefine)的情况。</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MGRAPH_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MGRAPH_H_</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">代码内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在头文件中加入这段代码，就可以避免引用时发生重定义，<code>_MGRAPH_H_</code>这个名字，只要能保证你在其它地方不会用到一模一样的名字即可，通常是用头文件的名字加上几个<code>_</code>来避免。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/04/YPKBxs.jpg&quot; alt=&quot;YPKBxs.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>DS浙大</title>
    <link href="http://yoursite.com/2020/04/01/DS%E6%B5%99%E5%A4%A7/"/>
    <id>http://yoursite.com/2020/04/01/DS浙大/</id>
    <published>2020-04-01T00:41:39.000Z</published>
    <updated>2020-05-01T00:16:38.570Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/uwCmQ0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/02/uwCmQ0.md.png" alt="uwCmQ0.md.png"></a></p><a id="more"></a><h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1-2-2"></a>1-2-2</h2><p>递归的空间复杂度很大：</p><p><a href="https://imgchr.com/i/3A2li4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/19/3A2li4.md.png" alt="3A2li4.md.png"></a></p><p>而循环通常只对一块内存反复使用。</p><p>计算机计算乘除法会比加减法慢很多。所以乘法越多，时间复杂度越大。</p><h2 id="1-2-3"><a href="#1-2-3" class="headerlink" title="1-2-3"></a>1-2-3</h2><p><code>Ω</code>表示复杂度上界</p><p><code>O</code>表示复杂度下界</p><p><code>Θ</code>表示上下界一致</p><p>具体如下：</p><p><a href="https://imgchr.com/i/3ATYy4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/19/3ATYy4.md.png" alt="3ATYy4.md.png"></a></p><h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><h2 id="课后练习-一元多项式的乘法与加法运算"><a href="#课后练习-一元多项式的乘法与加法运算" class="headerlink" title="课后练习 一元多项式的乘法与加法运算"></a>课后练习 一元多项式的乘法与加法运算</h2><h2 id="函数题-02-线性结构1-两个有序链表序列的合并"><a href="#函数题-02-线性结构1-两个有序链表序列的合并" class="headerlink" title="函数题:02-线性结构1 两个有序链表序列的合并"></a>函数题:<strong>02-线性结构1</strong> <strong>两个有序链表序列的合并</strong></h2><p><a href="https://imgchr.com/i/3R9DBQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/02/3R9DBQ.md.png" alt="3R9DBQ.md.png"></a></p><p>裁判测试程序样例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( List L )</span></span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = Read();</span><br><span class="line">    L2 = Read();</span><br><span class="line">    L = Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/3R9L36" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/02/3R9L36.md.png" alt="3R9L36.md.png"></a></p><h3 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h3><p>题目的关键：直接使用原序列中的结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">(List L1,List L2)</span></span>&#123;</span><br><span class="line">    List Head,t1,t2;</span><br><span class="line">    List L=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    L-&gt;Next=<span class="literal">NULL</span>;</span><br><span class="line">    Head=L;</span><br><span class="line"></span><br><span class="line">    t1=L1-&gt;Next;</span><br><span class="line">    t2=L2-&gt;Next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(t1 &amp;&amp; t2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;Data &lt;= t2-&gt;Data)&#123;</span><br><span class="line">            L-&gt;Next=t1;</span><br><span class="line">            L=t1;</span><br><span class="line">            t1=t1-&gt;Next;           </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(t2-&gt;Data &lt; t1-&gt;Data)&#123;</span><br><span class="line">            L-&gt;Next=t2;</span><br><span class="line">            L=t2;</span><br><span class="line">            t2=t2-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    L-&gt;Next= t1 ? t1:t2;<span class="comment">// (1)</span></span><br><span class="line">    L1-&gt;Next=<span class="literal">NULL</span>;      <span class="comment">// (2)</span></span><br><span class="line">    L2-&gt;Next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1)可以用来代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t1)</span><br><span class="line">L-&gt;next=t1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L-&gt;next=t2;</span><br></pre></td></tr></table></figure><p>用来挂上剩余的链表。</p><p>（2）题目要求在原来的链表上操作，因此完成后需要把L1和L2设置为空链表。</p><h1 id="第三周-树-上"><a href="#第三周-树-上" class="headerlink" title="第三周 树(上)"></a>第三周 树(上)</h1><blockquote><p>树的问题本质上是通过递归的方式简化为“根左右”的方式来处理。</p></blockquote><p><a href="https://imgchr.com/i/8neNP1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/13/8neNP1.md.png" alt="8neNP1.md.png"></a></p><p>一棵树想用顺序存储结构来表示显然是不方便的，因此我们通常用链式存储结构来表示。</p><p><a href="https://imgchr.com/i/8n3Za8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/13/8n3Za8.png" alt="8n3Za8.png"></a></p><p>对于这棵树，优先能想到的链式表示方法如下：</p><p><a href="https://imgchr.com/i/8n3UG4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/13/8n3UG4.png" alt="8n3UG4.png"></a></p><p>这种方法有个缺陷，需要定义多种不同类型的结构体，非常不方便。如果我们把所有结点设计成度最大的结构，对于指针域又是一种极大浪费，因此就引入了<strong>孩子兄弟表示法。</strong>如图所示：</p><p><a href="https://imgchr.com/i/8n3Tdf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/13/8n3Tdf.png" alt="8n3Tdf.png"></a></p><p>这样只会浪费n+1个指针域，也统一了结点的样式，而右边这个样式，就是<strong>二叉树</strong>。</p><p><a href="https://imgchr.com/i/8n8iYF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/13/8n8iYF.png" alt="8n8iYF.png"></a></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote><p>二叉树是可以进行顺序存储的</p></blockquote><p>完全二叉树很适合顺序存储</p><p><a href="https://imgchr.com/i/8nBRWq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/13/8nBRWq.md.png" alt="8nBRWq.md.png"></a></p><p>非完全二叉树也可以顺序存储，只要将其补成完全二叉树即可，但会浪费很多空间：</p><p><a href="https://imgchr.com/i/8nDfNd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/13/8nDfNd.png" alt="8nDfNd.png"></a></p><h2 id="03-树1-树的同构"><a href="#03-树1-树的同构" class="headerlink" title="03-树1 树的同构"></a>03-树1 树的同构</h2><p><a href="https://imgchr.com/i/8lpvrQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/14/8lpvrQ.md.png" alt="8lpvrQ.md.png"></a></p><p><a href="https://imgchr.com/i/8l995q" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/14/8l995q.md.png" alt="8l995q.md.png"></a></p><p><a href="https://imgchr.com/i/8l9uI1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/14/8l9uI1.md.png" alt="8l9uI1.md.png"></a></p><p><a href="https://imgchr.com/i/8l9TL4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/14/8l9TL4.md.png" alt="8l9TL4.md.png"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tree int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    Tree left;</span><br><span class="line">    Tree right;</span><br><span class="line">&#125;T1[MaxSize],T2[MaxSize];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">treeNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">(treeNode T[])</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">isomorphic</span><span class="params">(Tree R1,Tree R2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree R1,R2;</span><br><span class="line"></span><br><span class="line">    R1=BuildTree(T1);</span><br><span class="line">    R2=BuildTree(T2);</span><br><span class="line">    <span class="keyword">if</span>(isomorphic(R1,R2)) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">(treeNode T[])</span></span>&#123;</span><br><span class="line">    Tree n,root=Null;<span class="comment">//如果是空树返回null</span></span><br><span class="line">    <span class="keyword">char</span> cl,cr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    Tree check[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            check[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顺序存储二叉树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c %c %c"</span>,&amp;T[i].data,&amp;cl,&amp;cr);    <span class="comment">// (1)</span></span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span>(cl!=<span class="string">'-'</span>)</span><br><span class="line">                T[i].left=cl-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].left=Null;</span><br><span class="line">            <span class="keyword">if</span>(cr!=<span class="string">'-'</span>)</span><br><span class="line">                T[i].right=cr-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].right=Null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//left和right中没出现过的序号就是根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T[i].left&gt;=<span class="number">0</span>)</span><br><span class="line">                check[T[i].left]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(T[i].right&gt;=<span class="number">0</span>)</span><br><span class="line">                check[T[i].right]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到根结点并返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!check[i])</span><br><span class="line">                root=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">isomorphic</span><span class="params">(Tree R1,Tree R2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((R1==Null)&amp;&amp;(R2==Null))<span class="comment">//both empty</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( (R1==Null) &amp;&amp; (R2!=Null) || (R1!=Null) &amp;&amp; (R2==Null) )<span class="comment">//one of them is empty</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( T1[R1].data!=T2[R2].data ) <span class="comment">//roots are different</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( (T1[R1].left==Null) &amp;&amp; (T2[R2].left==Null) ) <span class="comment">//both have no left subtree</span></span><br><span class="line">        <span class="keyword">return</span> isomorphic(T1[R1].right,T2[R2].right);</span><br><span class="line">    <span class="keyword">if</span>( ( (T1[R1].left!=Null) &amp;&amp; (T2[R2].left!=Null) ) &amp;&amp; (T1[T1[R1].left].data)==(T2[T2[R2].left].data) )</span><br><span class="line">        <span class="keyword">return</span> (isomorphic(T1[R1].left,T2[R2].left) &amp;&amp;</span><br><span class="line">                isomorphic(T1[R1].right,T2[R2].right));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (isomorphic(T1[R1].left,T2[R2].right) &amp;&amp;</span><br><span class="line">                 isomorphic(T1[R1].right,T2[R2].left));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（0）用静态链表来做这题，即下面例子中的存储格式：</p><p><a href="https://imgchr.com/i/8lCam4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/14/8lCam4.png" alt="8lCam4.png"></a></p><p>（1）<code>scanf()</code>中如果带有<code>\n</code>，那么只有当它遭遇到下一个非空格字符时才会执行。</p><p><a href="https://stackoverflow.com/questions/15443483/using-n-in-scanf-in-c" target="_blank" rel="noopener">Using “\n” in scanf() in C </a></p><h2 id="03-树2-List-Leaves"><a href="#03-树2-List-Leaves" class="headerlink" title="03-树2 List Leaves"></a>03-树2 List Leaves</h2><p><a href="https://imgchr.com/i/83UWQI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/15/83UWQI.md.png" alt="83UWQI.md.png"></a></p><p><a href="https://imgchr.com/i/83U7Fg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/15/83U7Fg.md.png" alt="83U7Fg.md.png"></a></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tree int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Tree length;</span><br><span class="line">    Tree data;</span><br><span class="line">    Tree left;</span><br><span class="line">    Tree right;</span><br><span class="line">&#125;T1[MaxSize],<span class="built_in">queue</span>[MaxSize];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">treeNode</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">(treeNode T[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchLeaf</span><span class="params">(Tree R)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//建立一棵树</span></span><br><span class="line">    Tree R1;</span><br><span class="line">    <span class="comment">//R1代表根节点下标</span></span><br><span class="line">    R1=BuildTree(T1);</span><br><span class="line">    <span class="comment">//输出叶子结点</span></span><br><span class="line">    searchLeaf(R1);</span><br><span class="line">    <span class="comment">//printf("%d",R1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchLeaf</span><span class="params">(Tree R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Tree front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    treeNode tempNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(R&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">/******层次遍历********/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点入队</span></span><br><span class="line">        <span class="built_in">queue</span>[rear]=T1[R];<span class="comment">//结构体数组元素可以直接赋值吗？</span></span><br><span class="line">        rear++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(front&lt;T1[R].length)&#123;</span><br><span class="line">            <span class="comment">//节点出队</span></span><br><span class="line">            tempNode=<span class="built_in">queue</span>[front];     <span class="comment">//(2)</span></span><br><span class="line">            front++;</span><br><span class="line">            <span class="comment">//每次扫描到一个节点就判断是否为叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>( (tempNode.left==Null) &amp;&amp; (tempNode.right==Null) )&#123;</span><br><span class="line">                <span class="built_in">printf</span>(i==<span class="number">0</span> ? <span class="string">"%d"</span>:<span class="string">" %d"</span>,tempNode.data);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tempNode.left!=Null)&#123;</span><br><span class="line">                <span class="comment">//将节点的孩子节点入队</span></span><br><span class="line">                <span class="built_in">queue</span>[rear]=T1[tempNode.left];</span><br><span class="line">                rear++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tempNode.right!=Null)&#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear]=T1[tempNode.right];</span><br><span class="line">                rear++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//树为空的情况</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Null\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">(treeNode T[])</span></span>&#123;</span><br><span class="line">    Tree N,root=Null;</span><br><span class="line">    <span class="keyword">char</span> cl,cr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    getchar();</span><br><span class="line">    Tree check[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) check[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(N)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c %c"</span>,&amp;cl,&amp;cr);</span><br><span class="line">            getchar();</span><br><span class="line">            T[i].data=i;</span><br><span class="line">            T[i].length=N;</span><br><span class="line">            <span class="keyword">if</span>(cl!=<span class="string">'-'</span>)&#123;</span><br><span class="line">                T[i].left=cl-<span class="string">'0'</span>;</span><br><span class="line">                check[T[i].left]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> T[i].left=Null;</span><br><span class="line">            <span class="keyword">if</span>(cr!=<span class="string">'-'</span>)&#123;</span><br><span class="line">                T[i].right=cr-<span class="string">'0'</span>;</span><br><span class="line">                check[T[i].right]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> T[i].right=Null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!check[i])&#123;</span><br><span class="line">                root=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1)层序遍历需要用到队列，为了方便我直接用了顺序存储的队列。</p><p>(2)一般来说，结构体变量可以用另一个变量对其进行赋值和初始化，但是成员中含有指针时上面的情况就无法实现。</p><p><a href="https://blog.csdn.net/chenzhen1080/article/details/83239743" target="_blank" rel="noopener">C语言中结构体直接赋值？</a></p><h1 id="第四周-树-中"><a href="#第四周-树-中" class="headerlink" title="第四周 树(中)"></a>第四周 树(中)</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>查找分为<strong>静态查找</strong>和<strong>动态查找</strong>（查找过程中需要插入，删除等操作）。我们知道二分查找可以提高查找效率，是因为其查找过程可以建立为一棵树，因此我们不如直接将数据的形式按照树的方式存储，这样还可以进行动态查找，这棵树就叫二叉搜索树。</p><p>如何建立一棵二叉搜索树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//建立一棵二叉搜索树    </span></span><br><span class="line">    TreeNode T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V);<span class="comment">//读入第一个节点</span></span><br><span class="line">    T=newNode(V);<span class="comment">//建立根节点  (1)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V);</span><br><span class="line">        <span class="comment">//插入新节点</span></span><br><span class="line">        T=insertNode(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建节点</span></span><br><span class="line"><span class="function">TreeNode <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">     TreeNode T=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">     T-&gt;data=v;</span><br><span class="line">     T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">     T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">     T-&gt;flag=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点建立二叉搜索树</span></span><br><span class="line"><span class="function">TreeNode <span class="title">insertNode</span><span class="params">(TreeNode T,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T=newNode(V); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V&gt;T-&gt;data)</span><br><span class="line">            T-&gt;right=insertNode(T-&gt;right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;left=insertNode(T-&gt;left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于建树的一些小tip：</p><p>(1) 先建立根节点，再读入，<strong>这样才能把根节点记录下来</strong></p><p>(2)建树的过程大致为：先建立节点，再插入树中。</p><h2 id="04-树4-是否同一棵二叉搜索树-25分"><a href="#04-树4-是否同一棵二叉搜索树-25分" class="headerlink" title="04-树4 是否同一棵二叉搜索树 (25分)"></a>04-树4 是否同一棵二叉搜索树 (25分)</h2><p><a href="https://imgchr.com/i/GmMMEn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/30/GmMMEn.md.png" alt="GmMMEn.md.png"></a></p><p><a href="https://imgchr.com/i/GmMfUI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/30/GmMfUI.md.png" alt="GmMfUI.md.png"></a></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造出一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flag;<span class="comment">//标记节点是否被访问过，用来判断系列是否一致</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">insertNode</span><span class="params">(TreeNode *T,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(TreeNode *T,<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(TreeNode *T,<span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetTree</span><span class="params">(TreeNode *T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(TreeNode *T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    TreeNode *T;</span><br><span class="line">    <span class="comment">//每个序列插入N个元素</span></span><br><span class="line">    <span class="comment">//读入N=0时退出</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        <span class="comment">//对比序列个数L</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;L);</span><br><span class="line">        <span class="comment">//建立第一棵树</span></span><br><span class="line">        T=makeTree(N);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读入测试序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(judge(T,N)) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            resetTree(T);   <span class="comment">//清除tag，下个序列进行比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        freeTree(T);    <span class="comment">//这组测试结束，释放当前建立的基准树，为下一组数据做准备</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetTree</span><span class="params">(TreeNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        resetTree(T-&gt;left);</span><br><span class="line">        resetTree(T-&gt;right);</span><br><span class="line">        T-&gt;flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(TreeNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        freeTree(T-&gt;left);</span><br><span class="line">        freeTree(T-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(TreeNode *T,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="comment">//读入N个序列</span></span><br><span class="line">    <span class="keyword">int</span> V=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V);<span class="comment">//读入一个节点</span></span><br><span class="line">        <span class="keyword">if</span>( !check(T,V) ) flag=<span class="number">1</span>;<span class="comment">//和树做比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(TreeNode *T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前节点访问过</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V&gt;T-&gt;data) <span class="keyword">return</span> check(T-&gt;right,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (V&lt;T-&gt;data) <span class="keyword">return</span> check(T-&gt;left,V);<span class="comment">//对比序列个数L</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//序列中两个节点相等，则认与二叉树不一致</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(V==T-&gt;data)&#123;</span><br><span class="line">            T-&gt;flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//建立一棵二叉搜索树    (1)</span></span><br><span class="line">    TreeNode *T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V);<span class="comment">//读入第一个节点</span></span><br><span class="line">    T=newNode(V);<span class="comment">//建立根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V);</span><br><span class="line">        <span class="comment">//插入新节点</span></span><br><span class="line">        T=insertNode(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">     TreeNode *T=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">     T-&gt;data=V;</span><br><span class="line">     T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">     T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">     T-&gt;flag=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">insertNode</span><span class="params">(TreeNode *T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T=newNode(V);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V&gt;T-&gt;data)</span><br><span class="line">            T-&gt;right=insertNode(T-&gt;right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;left=insertNode(T-&gt;left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04-树5-Root-of-AVL-Tree-25分"><a href="#04-树5-Root-of-AVL-Tree-25分" class="headerlink" title="04-树5 Root of AVL Tree (25分)"></a>04-树5 Root of AVL Tree (25分)</h2><p><a href="https://imgchr.com/i/G0lkwT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/04/G0lkwT.md.png" alt="G0lkwT.md.png"></a></p><p><a href="https://imgchr.com/i/G0lLcR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/04/G0lLcR.md.png" alt="G0lLcR.md.png"></a></p><p><a href="https://imgchr.com/i/G0194e" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/04/G0194e.md.png" alt="G0194e.md.png"></a></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造出一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">createTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function">TreeNode *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function">TreeNode *<span class="title">LLRotation</span><span class="params">(TreeNode *A)</span></span>;</span><br><span class="line"><span class="function">TreeNode *<span class="title">RRRotation</span><span class="params">(TreeNode *A)</span></span>;</span><br><span class="line"><span class="function">TreeNode *<span class="title">LRRotation</span><span class="params">(TreeNode *A)</span></span>;</span><br><span class="line"><span class="function">TreeNode *<span class="title">RLRotation</span><span class="params">(TreeNode *A)</span></span>;</span><br><span class="line"><span class="function">TreeNode *<span class="title">insertNode</span><span class="params">(TreeNode *T,<span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">0</span>;</span><br><span class="line">    TreeNode *T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    T=createTree(N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">createTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//T为根节点</span></span><br><span class="line">    TreeNode *T=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V);</span><br><span class="line">        <span class="comment">//节点插入树中</span></span><br><span class="line">        T=insertNode(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    TreeNode *T=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    T-&gt;data=V;</span><br><span class="line">    <span class="comment">//这里的高度是从0开始算起，有些书是从1开始</span></span><br><span class="line">    T-&gt;height=<span class="number">0</span>;</span><br><span class="line">    T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">insertNode</span><span class="params">(TreeNode *T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//怎么找到需要计算平衡因子的节点  (2)递归思想</span></span><br><span class="line">    <span class="keyword">if</span>(!T) T=newNode(V);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data&gt;V)&#123;</span><br><span class="line">        T-&gt;left=insertNode(T-&gt;left,V);</span><br><span class="line">        <span class="comment">/* 比较左右子树的高度 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        代码中可以看出找到需要调整的子树的方法：</span></span><br><span class="line"><span class="comment">        1、插入一个结点后，从叶子回溯至根结点。</span></span><br><span class="line"><span class="comment">        2、最近的平衡因子=2的结点到插入的叶子结点，其路径上的某三个结点就是需要调整的结点（不一定包括叶子结点）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(getHeight(T-&gt;left)-getHeight(T-&gt;right)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(V&lt;T-&gt;left-&gt;data) <span class="comment">//LL单旋</span></span><br><span class="line">                T=LLRotation(T);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(V&gt;T-&gt;left-&gt;data)</span><br><span class="line">                T=LRRotation(T); <span class="comment">//LR双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data&lt;V)&#123;</span><br><span class="line">        T-&gt;right=insertNode(T-&gt;right,V);</span><br><span class="line">        <span class="keyword">if</span>(getHeight(T-&gt;right)-getHeight(T-&gt;left)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(V&gt;T-&gt;right-&gt;data) <span class="comment">//RR单旋</span></span><br><span class="line">                T=RRRotation(T);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(V&lt;T-&gt;right-&gt;data)</span><br><span class="line">                T=RLRotation(T); <span class="comment">//RL双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;height=Max(getHeight(T-&gt;left),getHeight(T-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">LLRotation</span><span class="params">(TreeNode *A)</span></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            A</span></span><br><span class="line"><span class="comment">           /</span></span><br><span class="line"><span class="comment">          B</span></span><br><span class="line"><span class="comment">         / \</span></span><br><span class="line"><span class="comment">        C   D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    TreeNode *B=A-&gt;left;</span><br><span class="line">    A-&gt;left=B-&gt;right;  <span class="comment">//把D挂到A的左子树上</span></span><br><span class="line">    B-&gt;right=A;        <span class="comment">//把A挂到B的右子树上</span></span><br><span class="line">    A-&gt;height=Max(getHeight(A-&gt;left),getHeight(A-&gt;right))+<span class="number">1</span>;<span class="comment">//结点高度=max(左右子树的高度)+1</span></span><br><span class="line">    B-&gt;height=Max(getHeight(B-&gt;left),A-&gt;height)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            B</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          C   A</span></span><br><span class="line"><span class="comment">             /</span></span><br><span class="line"><span class="comment">            D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">RRRotation</span><span class="params">(TreeNode *A)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            A</span></span><br><span class="line"><span class="comment">             \</span></span><br><span class="line"><span class="comment">              B</span></span><br><span class="line"><span class="comment">             / \</span></span><br><span class="line"><span class="comment">            D   C</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     TreeNode *B=A-&gt;right;</span><br><span class="line">     A-&gt;right=B-&gt;left;</span><br><span class="line">     B-&gt;left=A;</span><br><span class="line">     A-&gt;height=Max(getHeight(A-&gt;left),getHeight(A-&gt;right))+<span class="number">1</span>;</span><br><span class="line">     B-&gt;height=Max(getHeight(B-&gt;right),A-&gt;height);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> B;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            B</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          A   C</span></span><br><span class="line"><span class="comment">           \</span></span><br><span class="line"><span class="comment">            D</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">LRRotation</span><span class="params">(TreeNode *A)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            A</span></span><br><span class="line"><span class="comment">           /</span></span><br><span class="line"><span class="comment">          B</span></span><br><span class="line"><span class="comment">           \</span></span><br><span class="line"><span class="comment">            C</span></span><br><span class="line"><span class="comment">           /</span></span><br><span class="line"><span class="comment">          D</span></span><br><span class="line"><span class="comment">    LR型，三个结点关系：B&lt;C&lt;A</span></span><br><span class="line"><span class="comment">    所以要把C调整为根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先以B为根结点RR</span></span><br><span class="line">    A-&gt;left=RRRotation(A-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再以A为根结点LL</span></span><br><span class="line">    <span class="keyword">return</span> LLRotation(A);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            C</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          B   A</span></span><br><span class="line"><span class="comment">           \</span></span><br><span class="line"><span class="comment">            D</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">RLRotation</span><span class="params">(TreeNode *A)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            A</span></span><br><span class="line"><span class="comment">             \</span></span><br><span class="line"><span class="comment">              B</span></span><br><span class="line"><span class="comment">             /</span></span><br><span class="line"><span class="comment">            C</span></span><br><span class="line"><span class="comment">             \</span></span><br><span class="line"><span class="comment">              D</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对B先做LL旋转</span></span><br><span class="line">    A-&gt;right=LLRotation(A-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对A做RR旋转</span></span><br><span class="line">    <span class="keyword">return</span> RRRotation(A);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            C</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          A   B</span></span><br><span class="line"><span class="comment">             /</span></span><br><span class="line"><span class="comment">             D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;=b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何获得左右子树的孩子节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T==<span class="literal">NULL</span>?<span class="number">-1</span>:T-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AVL树的关键：</p><p>1、判断失衡的类型(LL、RR、LR、RL)</p><p>插入新结点后，找到失衡结点，从失衡结点开始到新结点的路径中数3个结点，他们所构成的就是失衡类型（需要调整的结点并不一定包括新插入结点）</p><p>2、LL、RR、LR、RL调整方法</p><p>见注释</p><h1 id="第五周-树-下"><a href="#第五周-树-下" class="headerlink" title="第五周 树(下)"></a>第五周 树(下)</h1><h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>如果我们需要一个队列，按照优先级而不是FIFO的形式出队，有下面几种构造方法：</p><p><a href="https://imgchr.com/i/GB1nFU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/05/GB1nFU.png" alt="GB1nFU.png"></a></p><p>我们发现无论使用那种结构，时间复杂度都为O(n)，但如果使用二叉树的方法，可以大大降低时间复杂度。这种二叉树结构称之为“堆”。</p><p>在二叉搜索树中，我们知道搜索树的时间复杂度和树的高度有关，因此我们可以用完全二叉树来保持堆的左右子树的平衡，而为了方便删除最大优先级(或最小，以下都以最大为例)结点，我们把优先级最大的结点记为根结点。</p><p>因此，堆的两个条件：</p><ul><li>完全二叉树</li><li>任一子树，其根结点优先级都大于其所有孩子结点</li></ul><p>因此自顶向下沿着任一路径，结点优先级都是从大到小，我们称为大顶堆（根节点优先级最小，称为小顶堆）。</p><h3 id="堆的插入与删除"><a href="#堆的插入与删除" class="headerlink" title="堆的插入与删除"></a>堆的插入与删除</h3><p>以最大堆为例，树中元素顺序存储。</p><ul><li><p>插入</p><p> 完全二叉树在最后插入元素，同自己的父结点比较，若大于父节点，则和父节点交换。</p></li><li><p>删除</p><p>删除堆的根节点元素，用最后一个元素代替，然后与左右孩子结点比较，将其中值最大的移动到根节点。</p></li></ul><h2 id="05-树7-堆中的路径"><a href="#05-树7-堆中的路径" class="headerlink" title="05-树7 堆中的路径"></a>05-树7 堆中的路径</h2><p><a href="https://imgchr.com/i/G2KmdA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/07/G2KmdA.md.png" alt="G2KmdA.md.png"></a></p><p><a href="https://imgchr.com/i/G2K0zT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/07/G2K0zT.md.png" alt="G2K0zT.md.png"></a></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINH -10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H[MAXN],size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHeap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertHeap</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">0</span>,M=<span class="number">0</span>; <span class="comment">//N为插入元素个数;M为路径条数;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        insertHeap(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        printHeap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;node);</span><br><span class="line">    <span class="keyword">for</span>(;node&gt;<span class="number">0</span>;node/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(flag==<span class="number">0</span>?<span class="string">"%d"</span>:<span class="string">" %d"</span>,H[node]);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertHeap</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 每插入一个元素，和父节点比较，小于父节点则交换 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;H[i]);</span><br><span class="line">    <span class="comment">//和父节点比较</span></span><br><span class="line">    <span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(H[i]&lt;H[i/<span class="number">2</span>])&#123;</span><br><span class="line">            temp=H[i/<span class="number">2</span>];</span><br><span class="line">            H[i/<span class="number">2</span>]=H[i];</span><br><span class="line">            H[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    H[<span class="number">0</span>]=MINH;</span><br><span class="line">    size=<span class="number">0</span>;<span class="comment">//设置哨兵</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方参考代码：</p><p>插入结点（建堆）：</p><p><a href="https://imgchr.com/i/G2QS9x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/07/G2QS9x.png" alt="G2QS9x.png"></a></p><h2 id="05-树8-File-Transfer"><a href="#05-树8-File-Transfer" class="headerlink" title="05-树8 File Transfer"></a>05-树8 File Transfer</h2><p><a href="https://imgchr.com/i/JFF0KI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFF0KI.md.png" alt="JFF0KI.md.png"></a></p><p><a href="https://imgchr.com/i/JFFOz9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFFOz9.md.png" alt="JFFOz9.md.png"></a></p><p><a href="https://imgchr.com/i/JFkVsI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFkVsI.md.png" alt="JFkVsI.md.png"></a></p><p><a href="https://imgchr.com/i/JFklWQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFklWQ.md.png" alt="JFklWQ.md.png"></a></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Setname;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> ElementType SetType;<span class="comment">/*定义一个elementType数组类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeUFS</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkUnion</span><span class="params">(SetType S[])</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Find</span><span class="params">(SetType S[],ElementType node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputUnion</span><span class="params">(SetType S[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[],ElementType root1,ElementType root2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchUnion</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> in;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    SetType S[N];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    initializeUFS(S,N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;in);</span><br><span class="line">        <span class="keyword">switch</span>(in)&#123;</span><br><span class="line">            <span class="comment">//检查</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                checkUnion(S);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//连接</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                inputUnion(S);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//相连的机器</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                searchUnion(S,N);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(in!=<span class="string">'S'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeUFS</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        S[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkUnion</span><span class="params">(SetType S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    ElementType root1=<span class="number">0</span>,root2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="comment">//找到两台机器根结点</span></span><br><span class="line">    root1=Find(S,a<span class="number">-1</span>);<span class="comment">/*下标要-1*/</span></span><br><span class="line">    root2=Find(S,b<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root1==root2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Find</span><span class="params">(SetType S[],ElementType node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;S[node]&gt;=<span class="number">0</span>;node=S[node])</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputUnion</span><span class="params">(SetType S[])</span></span>&#123;</span><br><span class="line">    Setname a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    ElementType root1=<span class="number">0</span>,root2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    root1=Find(S,a<span class="number">-1</span>);</span><br><span class="line">    root2=Find(S,b<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root1!=root2)</span><br><span class="line">        Union(S,root1,root2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[],ElementType root1,ElementType root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把root1挂在root2下面*/</span></span><br><span class="line">    S[root1]=root2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchUnion</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==<span class="number">-1</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The network is connected.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"There are %d components.\n"</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><a href="https://imgchr.com/i/JFkjfg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFkjfg.md.png" alt="JFkjfg.md.png"></a></p><p>之所以会运行超时，原因在于，原代码中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[],ElementType root1,ElementType root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把root1挂在root2下面*/</span></span><br><span class="line">    S[root1]=root2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>极端情况下会导致树高不断增加，出现下面的情况：</p><p><a href="https://imgchr.com/i/JFVndx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFVndx.png" alt="JFVndx.png"></a></p><p>解决方法有两种</p><ul><li><p>按秩归并</p><ul><li>按树高归并</li></ul><p><a href="https://imgchr.com/i/JFKMFI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFKMFI.png" alt="JFKMFI.png"></a></p></li></ul><ul><li><p>按规模归并</p><p><a href="https://imgchr.com/i/JFKdkn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFKdkn.png" alt="JFKdkn.png"></a></p></li></ul><ul><li><p>路径压缩</p><p><a href="https://imgchr.com/i/JFMSc8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFMSc8.png" alt="JFMSc8.png"></a></p><p>最后采用路径压缩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Setname;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> ElementType SetType;<span class="comment">/*定义一个elementType数组类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeUFS</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkUnion</span><span class="params">(SetType S[])</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Find</span><span class="params">(SetType S[],ElementType node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputUnion</span><span class="params">(SetType S[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[],ElementType root1,ElementType root2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchUnion</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> in;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    SetType S[N];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    initializeUFS(S,N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;in);</span><br><span class="line">        <span class="keyword">switch</span>(in)&#123;</span><br><span class="line">            <span class="comment">//检查</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                checkUnion(S);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//连接</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                inputUnion(S);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//相连的机器</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                searchUnion(S,N);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(in!=<span class="string">'S'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeUFS</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        S[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkUnion</span><span class="params">(SetType S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    ElementType root1=<span class="number">0</span>,root2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="comment">//找到两台机器根结点</span></span><br><span class="line">    root1=Find(S,a<span class="number">-1</span>);<span class="comment">/*下标要-1*/</span></span><br><span class="line">    root2=Find(S,b<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root1==root2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Find</span><span class="params">(SetType S[],ElementType node)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 一般方法</span></span><br><span class="line"><span class="comment">            1</span></span><br><span class="line"><span class="comment">             \</span></span><br><span class="line"><span class="comment">              2</span></span><br><span class="line"><span class="comment">               \</span></span><br><span class="line"><span class="comment">                3</span></span><br><span class="line"><span class="comment">    for(;S[node]&gt;=0;node=S[node])</span></span><br><span class="line"><span class="comment">            ;</span></span><br><span class="line"><span class="comment">    return node;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 路径压缩</span></span><br><span class="line"><span class="comment">            1</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          2   3</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(S[node]&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S[node]=Find(S,S[node]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputUnion</span><span class="params">(SetType S[])</span></span>&#123;</span><br><span class="line">    Setname a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    ElementType root1=<span class="number">0</span>,root2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    root1=Find(S,a<span class="number">-1</span>);</span><br><span class="line">    root2=Find(S,b<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root1!=root2)</span><br><span class="line">        Union(S,root1,root2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[],ElementType root1,ElementType root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  把root1挂在root2下面  */</span></span><br><span class="line">    S[root1]=root2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchUnion</span><span class="params">(SetType S[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==<span class="number">-1</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The network is connected.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"There are %d components.\n"</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第六周-图-上"><a href="#第六周-图-上" class="headerlink" title="第六周 图(上)"></a>第六周 图(上)</h1><p><a href="https://imgchr.com/i/JFHs2D" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JFHs2D.png" alt="JFHs2D.png"></a></p><h2 id="6-2图的遍历"><a href="#6-2图的遍历" class="headerlink" title="6.2图的遍历"></a>6.2图的遍历</h2><ul><li><p>深度优先搜索(deepth search first,DFS)</p><p>类似于先序遍历(递归，所以用到的是系统堆栈)</p></li><li><p>广度优先搜索(breath search first,BFS)</p><p>类似于层次遍历(需要用到辅助queue)</p></li></ul><h2 id="06-图1-列出连通集-25分"><a href="#06-图1-列出连通集-25分" class="headerlink" title="06-图1 列出连通集(25分)"></a>06-图1 列出连通集(25分)</h2><p>visited数组不要设置为DFS函数的局部变量 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/uwCmQ0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/02/uwCmQ0.md.png&quot; alt=&quot;uwCmQ0.md.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://yoursite.com/2019/10/02/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/10/02/时间复杂度/</id>
    <published>2019-10-02T14:34:02.000Z</published>
    <updated>2019-10-02T15:20:07.995Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/uwCmQ0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/02/uwCmQ0.md.png" alt="uwCmQ0.md.png"></a></p><a id="more"></a><blockquote><p>一些简单的时间复杂度计算</p></blockquote><h1 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">x=<span class="number">2</span>*x</span><br></pre></td></tr></table></figure><p>step-1:确定基本操作语句：<code>x=2*x</code></p><p>step-2:设这一语句执行了t次，则有$2^t+1&lt;\frac{n}{2}$，所以又$f(n)=log_2{\frac{n}{2}-1}=log_2{n}-2$</p><p>step-3:用大O表示法:$T(n)=O(f(n))=O(log_2{n})$</p><h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;m)</span><br><span class="line">&#123;</span><br><span class="line">j=j*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.while语句中的时间复杂度？</p><p>设基本操作语句$j=j*2$执行了t次，则有$2^t&lt;m$即$f(m)=log_2{m}$，用大O表示法$T(m)=O(log_{2}{m})$。</p><p>2.整个程序的时间复杂度为多少？</p><p>外层<code>for</code>循环执行了n-1次，内层执行了$log_2{m}$次，则整个程序执行了$O(nlog_2{m})$</p><h1 id="嵌套类型2"><a href="#嵌套类型2" class="headerlink" title="嵌套类型2"></a>嵌套类型2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j++)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">//此处运行次数:N+N-1+N-2+...+1=1+2+3+...+N=N(N+1)/2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当i=0，内循环执行n次；当i=1，内循环执行n-1次；….当i=n-1，内循环执行1次； 所以S(n)=1+2+……n;        $S(n)=\frac{n(1+n)}{2}=\frac{n^2}{2}+\frac{n}{2}$;</p><p>再加上外循环的执行次数n，$T(n)=O(\frac{n^2}{2}+\frac{n}{2}+n)$ 根据只保留最高阶项的原则，$Tn=O(n^2)$</p><h1 id="递归类型"><a href="#递归类型" class="headerlink" title="递归类型"></a>递归类型</h1><p>1、考研数据结构中关于时间复杂度的计算 - 灰灰的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/28224368" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28224368</a></p><p>（参见文章的汉诺塔问题，里面有个错误：迭代法最后得到的应该为:$T(n)=2^{n-1}T(1)+1+…+2^n$,原文漏了$2^{n-1}$这个系数。）</p><p>2.下面的写法也可以，其中b和c皆为常量级，c前面的系数比1中写法的更简洁。</p><p><a href="https://imgchr.com/i/udvfwd" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/02/udvfwd.md.png" alt="udvfwd.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/uwCmQ0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/02/uwCmQ0.md.png&quot; alt=&quot;uwCmQ0.md.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="http://yoursite.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>操作系统—生产者与消费者</title>
    <link href="http://yoursite.com/2019/09/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-PV%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/09/14/操作系统笔记-PV操作/</id>
    <published>2019-09-14T15:03:30.000Z</published>
    <updated>2019-09-15T00:04:08.807Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>天勤计算机考研笔记</p></blockquote><p>PV操作中经典的<strong>生成者(producer)和消费者(consumer)问题</strong>：</p><p><img src="https://s2.ax1x.com/2019/09/14/nyLIq1.png" alt="nyLIq1.png"></p><a id="more"></a><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>生产者—消费者问题，实际上就是二者共用了一块缓冲区（题中的仓库），所以生产者之间和消费者之间是互斥的关系，但同时生产者消费者之间又是协同的关系，所以将其归类为进程同步问题。</p><h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><p>根据问题，我们很容易写出下面的代码，其中的<code>item</code>即“产品”。</p><p><a href="https://imgchr.com/i/nyONe1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/nyONe1.md.png" alt="nyONe1.md.png"></a></p><p>但执行之后可能会产生一个很严重的问题：因为程序是并发执行的，所以很可能导致<code>producer()</code>进程执行到某条语句的时候，因为调度的原因，cpu被分配给了<code>consumer()</code>进程。严重情况下，可能会导致二者都进入阻塞状态，如下图情况：</p><p><a href="https://imgchr.com/i/nyzaGV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/nyzaGV.md.png" alt="nyzaGV.md.png"></a></p><p>这种情况也称为<strong>死锁</strong>。</p><p>发生这种情况的根本原因，是因为对于<code>producer</code>和<code>consumer</code>这两个进程而言，本题中的“仓库”是<strong>临界资源</strong>，（访问仓库的代码<code>putItemIntoBuffer()</code>称为<strong>临界区</strong>），多个进程同时访问临界资源，就可能导致问题，这个问题也叫<strong>竞争条件(Race condition)</strong>。</p><h1 id="解决方案1-1—同步问题"><a href="#解决方案1-1—同步问题" class="headerlink" title="解决方案1.1—同步问题"></a>解决方案1.1—同步问题</h1><p>为了解决竞争条件问题，就引入了信号量。</p><p>其实方案1中的<code>itemCount</code>也是信号，但它仅仅解决了是否阻塞/唤醒合作进程，没能说明具体阻塞/唤醒几个进程，也就是说没能体现出<strong>量</strong>的概念。</p><p>所以我们换个方式，对于<code>producer</code>，我们关注仓库中还有多少个空位置<code>empty</code>，而对于<code>consumer</code>则关注仓库中已放入多少个产品<code>full</code>。这就达到不再使用临界资源的情况。如下图所示：</p><p><a href="https://imgchr.com/i/n6PrNj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/n6PrNj.md.png" alt="n6PrNj.md.png"></a></p><p>从图中可以看出，<code>producer</code>实际上是在不断消耗空位置个数，如果cpu始终在执行<code>producer</code>，那么<code>empty</code>被消耗为空，<code>producer</code>被阻塞，继续执行的话<code>empty</code>小于0，其绝对值就等于被阻塞的进程数。</p><p>同理，<code>full&lt;0</code>的绝对值就是<code>consumer</code>被阻塞的进程数。</p><blockquote><p>注意：这里当empty和full都大于0时，表示的是空位数和产品数。但是当二者小于0时，代表的是阻塞的producer和consumer！！！</p></blockquote><p>从上面可以看出，<code>empty</code>和<code>full</code>存在逻辑上相反的关系，即$empty=n-full$，但是在各自的进程中，其过程又具有相似性，因此我们可以抽象出一个值，记为<code>value</code>，其结构体如下图所示：</p><p><a href="https://imgchr.com/i/n6RpuD" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/n6RpuD.md.png" alt="n6RpuD.md.png"></a></p><p>图中的两个函数就是<strong>PV操作</strong>。</p><p>接下来就可以改写<code>producer</code>和<code>consumer</code>的代码：</p><p><a href="https://imgchr.com/i/n6Rev8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/n6Rev8.md.png" alt="n6Rev8.md.png"></a></p><p>先来看<code>producer()</code>：</p><p>P操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(empty);</span><br></pre></td></tr></table></figure><p>传入参数<code>empty</code>，如果<code>empty</code>自减后小于0，则说明仓库中没有空位置，则把当前的<code>producer</code>阻塞掉；如果<code>empty</code>自减后大于0，则说明仓库中仍然有位置，则继续执行当前进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putItemIntoBuffer();<span class="comment">//往仓库中加入一个商品</span></span><br></pre></td></tr></table></figure><p>再执行V操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V(full)</span><br></pre></td></tr></table></figure><p>当前的进程使用完了临界资源，则需要将<code>full</code>+1，即释放了一个资源，例子中也就是产品数+1。值得注意的是若<code>full</code>+1&lt;=0，那说明<code>consumer</code>之前有阻塞。</p><blockquote><p><strong>S小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？</strong></p><p>V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S&lt;0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完， 当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S&lt;0，表明有进程阻塞在该类资源上，于是唤醒一个。</p></blockquote><p>上面这段话，结合第一个引用中的内容更好理解。</p><p><strong>这里之前理解上还有个小误区，唤醒了<code>consumer</code>的进程是进入就绪态而不是执行态，因此当前的进程——这里是<code>producer</code>，还是需要继续执行直到完成。</strong></p><p>右边<code>consumer</code>的操作和<code>producer</code>类似。</p><h1 id="解决方案1-2—互斥问题"><a href="#解决方案1-2—互斥问题" class="headerlink" title="解决方案1.2—互斥问题"></a>解决方案1.2—互斥问题</h1><p>方案1.1解决了同步问题，但仍然存在互斥问题。即我们假设<code>putItemIntoBuffer（）</code>函数中的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer[i]=item;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>这样如果当<code>producer-1</code>执行到第一行语句时，cpu发生了调度，此时又有个进程<code>producer-2</code>执行了第一行语句，那么显然<code>Buffer[i]</code>中的元素就被覆盖掉了。</p><p>为了处理这个问题，我们只需要在一个进程执行上面两行代码时，不允许任何其他进程介入即可，如下图：</p><p><a href="https://imgchr.com/i/n6xKqH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/n6xKqH.md.png" alt="n6xKqH.md.png"></a></p><p>注意一下<code>empty</code>、<code>full</code>和<code>mutex</code>的初值。</p><p>最后得出一些小结论：</p><p><a href="https://imgchr.com/i/n6xUsg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/n6xUsg.md.png" alt="n6xUsg.md.png"></a></p><p><a href="https://imgchr.com/i/n6x0ds" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/14/n6x0ds.md.png" alt="n6x0ds.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;天勤计算机考研笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PV操作中经典的&lt;strong&gt;生成者(producer)和消费者(consumer)问题&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/14/nyLIq1.png&quot; alt=&quot;nyLIq1.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>简单理解P,NP,NPC,NPH</title>
    <link href="http://yoursite.com/2019/06/22/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3P-NP-NPC-NPH/"/>
    <id>http://yoursite.com/2019/06/22/简单理解P-NP-NPC-NPH/</id>
    <published>2019-06-22T15:37:10.000Z</published>
    <updated>2019-06-22T15:40:35.528Z</updated>
    
    <content type="html"><![CDATA[<p>0.<strong>复杂度</strong>：时间复杂度不是表示一个程序的运行时间，而是当问题规模扩大之后，程序需要的时间增长的有多快。</p><p>例如：四则运算，无论数据变得多大，程序的时间复杂度都为o(1);冒泡排序，数据扩大2倍，时间变4倍，程序的时间复杂度为o($n^2$)</p><p><strong>P问题</strong>:Polynomial-Problem,有一个确定型图灵机在多项式内解决的问题。</p><p><strong>NP问题</strong>:Non-deteministic polynomial(非确定性多项式) problem,能在多项式时间内<strong>验证</strong>某个猜想答案的正确性，但可能在无法再多项式时间内解决。比如：数独，很容易就确定一个答案是否正确，但确找不到一个公式来描述其规律。</p><p>所以现在面临的困难就是：P=NP？翻译过来就是能多项式时间内验证一个问题，是否能在多项式时间内解决一个问题？这也是千禧年世界七大数学难题之一。目前数学界倾向于不等，其中很重要的原因就是发现了NP-Complete。</p><p><strong>NP-Complete</strong>:需要满足两个条件：1.它本身是个NP问题。2.所有的NP问题都可以<a href="https://baike.baidu.com/item/%E7%BA%A6%E5%8C%96%E6%80%A7/19056493?fr=aladdin" target="_blank" rel="noopener">约化</a>到NP-complete。也就是说如果能证明NP-Complete=P，那么就基本可以证明NP=P。某种意义上说，NP-Complete问题就是NP问题中最难的那类。</p><p>比如：3SAT问题</p><p><strong>NP-hard</strong>：只需要满足NP-Complete的第二个条件。所以NP-hard要比NP-Complete范围更广，复杂度可能更高。比如：Turing Halting Problem。</p><p><img src="https://s2.ax1x.com/2019/06/22/Z9bJgO.png" alt="Z9bJgO.png"></p><p><strong>参考资料</strong></p><p>(1) <a href="http://www.matrix67.com/blog/archives/105" target="_blank" rel="noopener">什么是P问题、NP问题和NPC问题</a></p><p>(2)<a href="https://www.zhihu.com/question/27039635/answer/408025594" target="_blank" rel="noopener">怎么理解 P 问题和 NP 问题？ - Kimmi Meow的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;0.&lt;strong&gt;复杂度&lt;/strong&gt;：时间复杂度不是表示一个程序的运行时间，而是当问题规模扩大之后，程序需要的时间增长的有多快。&lt;/p&gt;
&lt;p&gt;例如：四则运算，无论数据变得多大，程序的时间复杂度都为o(1);冒泡排序，数据扩大2倍，时间变4倍，程序的时间复杂度为o(
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
      <category term="Decision tree" scheme="http://yoursite.com/tags/Decision-tree/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基石7|The VC Dimension</title>
    <link href="http://yoursite.com/2019/06/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B37-The-VC-Dimension/"/>
    <id>http://yoursite.com/2019/06/19/机器学习基石7-The-VC-Dimension/</id>
    <published>2019-06-19T10:09:11.000Z</published>
    <updated>2019-06-20T08:28:12.298Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/VHVk0s" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHVk0s.md.png" alt="VHVk0s.md.png"></a></p><a id="more"></a><p>—————————红色石头机器学习课程笔记7 &lt;节选&gt;—————————————</p><p> 在前几节课中，我们推导出机器要能够学习，必须满足两个条件：</p><ul><li>hypothesis $H$中的size M是有限的，N足够大，那么对于$H$中的任意一个假设$h$，$E_{o u t} \approx E_{i n}$</li><li>利用算法$A$从hypothesis中，挑选出一个$g$，使$E_{in}(g) \approx 0$，则$E_{o u t} \approx 0$。</li></ul><p>这第二个条件对应了train和test，train的目的是让损失期望$E_{i n}(g) \approx 0$；test目的是将算法运用到新样本时，损失期望也尽可能小，即$E_{o u t} \approx 0$。</p><p>正因为如此，上次课引入了break point，并推导出只要break point存在，则M有上界，一定存在$E_{o u t} \approx E_{i n}$。</p><p>这周的课程介绍VC Dimension，也是总结VC Dimension与$E_{i n}(g) \approx 0$，$E_{o u t} \approx 0$，Model Complexity Penalty的关系。</p><hr><h2 id="Definition-of-VC-Dimension"><a href="#Definition-of-VC-Dimension" class="headerlink" title="Definition of VC Dimension"></a>Definition of VC Dimension</h2><p>dichotomy的上限是成长函数，成长函数的上限是$B(N,k)$，$B(N,k)$的上限是$N^{k-1}$。</p><p><a href="https://imgchr.com/i/VH5N01" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH5N01.md.png" alt="VH5N01.md.png"></a></p><p>由下图可以更明显的看出，当$k \geq 3，N \geq 2$时，$N^{k-1}$大于$B(N,k)$。</p><p><img src="https://s2.ax1x.com/2019/06/17/VHI84f.png" alt="VHI84f.png"></p><p>因此这条结论的不等式为：</p><p>​                                                          $m_{H}(\mathrm{N})\leq B(\mathrm{N}, \mathrm{k})=\sum_{i=0}^{k-1} C_{N}^{i} \leq N^{k-1}$</p><p>因此上一周的VC bound就可以转换为只和K，N有关的式子：</p><p><a href="https://imgchr.com/i/VHTZOH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHTZOH.md.png" alt="VHTZOH.md.png"></a></p><p>通常情况N都足够大，因此只需要k满足条件即可。这时候我们就说$h$泛化能力不错，即$E_{o u t} \approx E_{i n}$。如果再有一个好的演算法$A$使得$E_{in} \approx 0$，那么理论上就这个模型就具有学习能力了。（真的好不好用还得要点运气….）</p><h3 id="VC-dimension"><a href="#VC-dimension" class="headerlink" title="VC dimension"></a>VC dimension</h3><p>通常来说break point越大的$H$，其复杂度也越高，这个复杂度比较抽象，通俗理解，就是$H$中的$h$，特征多，数量多，复杂度越高。</p><blockquote><p>这篇文章<a href="https://www.jianshu.com/p/cbe8e0fe7b2c" target="_blank" rel="noopener">《机器学习（周志华）》学习笔记（一）</a>里对假设空间$H$的说明可以参考一下，能够帮助直观理解$H$的复杂度。</p></blockquote><p>根据VC Theory，还可以用<strong>VC-dimension</strong>来描述$H$的复杂度，记为$d_{v c}(\mathcal{H})$。更重要的是</p><p>$k=d_{vc}(\mathcal{H})+1$，也就是说，$d_{vc}(\mathcal{H})$是$\mathcal{H}$能够shatter掉的数目，也就是比break point小1的点。如果不管多少个点$\mathcal{H}$都能shatter，那么$d_{v c}(H)=\infty$。</p><p>因此之前的条件，我们都可以把k替换成$d_{v c}(\mathcal{H})$：</p><p><img src="https://s2.ax1x.com/2019/06/17/VHHTwd.png" alt="VHHTwd.png"></p><p>那么无论采取什么样的$\mathcal{A}$，输入，目标函数，$d_{v c}(\mathcal{H})$都只和$H$有关，只要它finite，那么至少能保证$E_{o u t} \approx E_{i n}$。</p><h2 id="VC-Dimension-of-Perceptrons"><a href="#VC-Dimension-of-Perceptrons" class="headerlink" title="VC Dimension of Perceptrons"></a>VC Dimension of Perceptrons</h2><p>通过前面的证明，我们知道在2D情况下$d_{v c}=3$，PLA算法是可以学习的：</p><p><a href="https://imgchr.com/i/VbixXj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VbixXj.md.png" alt="VbixXj.md.png"></a></p><p>那么多个feature或者说多维的情况下，对应的$d_{v c}$又是多少？我们先给出结论（1D perceptron（pos/neg rays）$d_{vc}=2$；2D perceptrons $d_{vc}=3$，其中$d$为维数）：</p><p>​                                                                    $d_{v c}=d+1$</p><p>证明”=”通常我们分两步：</p><ul><li>$d_{v c} \geq d+1$</li><li>$d_{v c} \leq d+1$</li></ul><p>首先证明第一个不等式：$d_{v c} \geq d+1$，因为$d_{vc}$是break point-1，也就是$m_{H}(N)=2^{N}$成立且最大时的N值，所以要证明这个不等式，只需要证明存在<strong>某一个</strong>含有$d+1$个数据的数据集能够被shatter即可，即</p><p>$m_{H}(d+1)=2^{d+1}$。</p><p>假设我们有一个$d$维的矩阵$X$，含有$d+1$个inputs，每个inputs加上偏置项1，得到的新的矩阵$X$如下：</p><p><a href="https://imgchr.com/i/VLzFD1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VLzFD1.md.png" alt="VLzFD1.md.png"></a></p><p>可以明显看出$X$是可逆的，shatter的本质是假设空间$\mathcal{H}$里的每个$h$对$X$都能进行分类，也就是说总能找到权重$W$，满足$\operatorname{sign}(\mathbf{X} \mathbf{w})=\mathbf{y}$，而只要使得$\mathbf{X}_{\mathbf{W}}=\mathbf{y}$成立，$sign(\mathbf{X}_{\mathbf{W}})=\mathbf{y}$就一定成立，那么这个权重$W$存在吗？答案显而易见，只要令$W=X^{-1}y$（别忘了这里$X$可逆），那么$\mathbf{X}_{\mathbf{W}}=\mathbf{y}$就一定成立。</p><p>结论：$d$维 perceptrons，存在$N=d+1$时被shattered，因此$d_{v c} \geq d+1$。</p><p>接着证明第二个不等式$d_{v c} \leq d+1$。在$d$维里，对于<strong>任意</strong>的d+2个inputs都不能被shattered，则不等式成立。</p><p><a href="https://imgchr.com/i/VOCffK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VOCffK.md.png" alt="VOCffK.md.png"></a></p><p>添加偏置项后$X$为$d+1$列，矩阵秩不满，因此$\mathbf{X}_{d+2}$可以由$a_{1} \mathbf{x}_{1}+a_{2} \mathbf{x}_{2}+\ldots+a_{d+1} \mathbf{x}_{d+1}$线性表示：</p><p>$\mathbf{x}_{d+2}=a_{1} \mathbf{x}_{1}+a_{2} \mathbf{x}_{2}+\ldots+a_{d+1} \mathbf{x}_{d+1}$………………….(1)</p><p>现在用反证法来证明，我们假设$X$能被shattered，且存在一个$W$，使得$W^{T}X$的值(也就是y值，+1或-1)和系数$a_{i}$(i=1,2,….,d+1)符号一致。结合公式(1)得出：</p><p><img src="https://s2.ax1x.com/2019/06/19/VOk2uD.png" alt="VOk2uD.png"></p><p>其中，蓝色$a_{i}$为正，红色$a_{i}$为负。</p><p>但是由上面可以知道，此时$\mathbf{w}^{T} \mathbf{x}_{d+2} &gt;0$是恒成立的，也就是说第$\mathbf{w}^{T}\mathbf{x}_{d+2}$只能为”o”不能为”x”。同理，当</p><p>$\mathbf{w}^{T} \mathbf{x}_{d+2}&lt;0$，则$\mathbf{w}^{T}\mathbf{x}_{d+2}$只能为“x”，不能为“o”。</p><p>这就违背了shattered的原则，假设不成立，任意$d+2$个inputs都不可能被shattered。所以$d_{v c} \leq d+1$。</p><p>综上所述：d维perceptrons，$d_{v c}=d+1$。</p><h2 id="Physical-Intuition-of-VC-Dimension"><a href="#Physical-Intuition-of-VC-Dimension" class="headerlink" title="Physical Intuition of VC Dimension"></a>Physical Intuition of VC Dimension</h2><p>从上一part我们得知VC Dimension中的Dimension和perceptron中数据的Dimension是有关的，这也是VC维中维字的由来。而在perceptron中，数据样本的dimension加上偏置，就和权值的dimension一致，且权值又构成了假设函数。因此如果把hypothesis set想象成一个空间（即假设空间），那么其中的假设函数可以用权值参数向量$\mathbf{w}^{T}=\left[w_{0}, w_{1, \cdots} w_{d}\right]$来表示，向量的个数d就是假设空间的维度，即模型学习的参数个数，也称为”自由度”(degree of freedom)。</p><blockquote><p>对于$d_{vc}$较小的$\mathcal{H}$，可以从它最多能够shatter的点的数量，得到$d_{vc}$，但对于一些较为复杂的模型，寻找能够shatter掉的点的数量，就不太容易了。此时我们可以通过模型的自由度，来近似的得到模型的$d_{vc}$。</p></blockquote><p>因为假设空间的数量$|H|$是无限的，所以自由度也是无限的。当然如果我们从感知器在二元分类上这一限制条件入手，是可以使用VC维作为自由度的衡量。</p><p>举几个直观例子：</p><p><img src="https://s2.ax1x.com/2019/06/19/VO0MS1.png" alt="VO0MS1.png"></p><p>因此，</p><p><a href="https://imgchr.com/i/VO01OK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VO01OK.md.png" alt="VO01OK.md.png"></a></p><p><img src="https://s2.ax1x.com/2019/06/19/VO0znK.png" alt="VO0znK.png"></p><p>最后整理一下，通过这图，我们可以将假设空间中的假设函数个数$M$用$d_{vc}$来代替。这张图里说明了很多问题，比如large $d_{vc}$就证明了在特征很多的情况下，只要样本数量N够多，学习得到的模型$E_{in}(g)$都比较小，错误率也较低。</p><h2 id="Interpreting-VC-Dimension"><a href="#Interpreting-VC-Dimension" class="headerlink" title="Interpreting VC Dimension"></a>Interpreting VC Dimension</h2><p>之前定义过VC Bound：</p><p><a href="https://imgchr.com/i/VO2oBn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VO2oBn.md.png" alt="VO2oBn.md.png"></a></p><p>BAD发生的概率$\leq \delta$，反过来说good，即$\left|E_{\mathrm{in}}(g)-E_{\mathrm{out}}(g)\right|&lt;\epsilon$发生的概率$\geq 1-\delta$。因此我们可以推导出$E_{in}(g)$和$E_{out}(g)$的接近程度$\epsilon$：</p><p><a href="https://imgchr.com/i/VORNbn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VORNbn.md.png" alt="VORNbn.md.png"></a></p><p>我们又把接近程度$\left|E_{\mathrm{in}}(g)-E_{\mathrm{out}}(g)\right|$称为泛化误差(generalization error)，$\epsilon$称为泛化误差界。再进一步，可以确定$E_{out}(g)$的范围：</p><p><a href="https://imgchr.com/i/VOfntP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VOfntP.md.png" alt="VOfntP.md.png"></a></p><p>其中带根号这一项就被称为模型复杂度(model complexity)，由样本数量N，假设空间$\mathcal{H}$($d_{vc}$)，$\delta$有关。我们通常不关注左边灰色的式子，因此得到：</p><p><a href="https://imgchr.com/i/VOfcA1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VOfcA1.md.png" alt="VOfcA1.md.png"></a></p><p>可以绘制出$E_{out}(g)$、模型复杂度、$E_{in}(g)$随$d_{vc}$变化的函数图像：</p><p><a href="https://imgchr.com/i/VOhXI1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VOhXI1.md.png" alt="VOhXI1.md.png"></a></p><p>从图中可以看出，$d_{vc}$越大，假设空间就越大，就有可能选到更小的$E_{in}$；模型复杂度从公式中也可以看出和$d_{vc}$正相关。而我们希望的是能够让$E_{out}$最小，因此在学习中如何选择到$d_{vc}^{*}$就非常关键。</p><h3 id="sample-complexity"><a href="#sample-complexity" class="headerlink" title="sample complexity"></a>sample complexity</h3><p>VC Dimension还可以表示样本复杂度(sample complexity)。如果选定了$d_{vc}$，那么数据样本D选择多少合适？</p><p>假设你帮老板进行股票分析，老板要求：$E_{in}(g)$和$E_{out}(g)$之间的误差上限$\epsilon=0.1$；置信区间90%，即$\delta=0.1$；所用模型的VC Dimension $d_{vc}=3$。你经过一番计算，跟老板汇报：</p><p><a href="https://imgchr.com/i/VOTsBD" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VOTsBD.md.png" alt="VOTsBD.md.png"></a></p><p>如果想要满足条件，大概需要30000条数据作为训练集，也就是10000$d_{vc}$。这么多条数据，显然老板也无法解决这个问题。</p><p>好消息是，实际经验告诉我们，其实需要的数据量大概是10$d_{vc}$。那么为什么导致理论值和实际值差别如此大？原因是我们再推导VC Bound的时候考虑的都是比较泛化的情况，换句话说VC Bound过于”宽松“了，回顾我们的推导过程：</p><p><a href="https://imgchr.com/i/VOHTYj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VOHTYj.md.png" alt="VOHTYj.md.png"></a></p><p>加个中文版的：</p><p><a href="https://imgchr.com/i/VO7vid" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/19/VO7vid.md.png" alt="VO7vid.md.png"></a></p><p>为了能够适用于这么多的‘any’，导致了VC Bound的理论值变得非常宽松。因此我们得到的是一个比实际上大得多的上界。尽管VC Bound看起来非常宽松，但也很难找到一个比它更好的模型。值得欣慰的是，对于不同模型，VC Bound的宽松程度还是基本一致的。尽管在实际使用时我们不会严格根据VC Bound来选择，但它的推导过程还是能够帮助进一步理解为什么机器学习是成立的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/VHVk0s&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/17/VHVk0s.md.png&quot; alt=&quot;VHVk0s.md.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基石4|机器学习的可行性</title>
    <link href="http://yoursite.com/2019/06/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B34-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%80%A7/"/>
    <id>http://yoursite.com/2019/06/14/机器学习基石4-机器学习的可行性/</id>
    <published>2019-06-14T14:33:56.000Z</published>
    <updated>2019-06-14T14:33:56.609Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习基石在证明过程中的思想，可以类比于集合论的思想，比如$f$是最完美的模型(函数)，那么$h$是<strong>假设函数空间(hypothesis  set)</strong>$H$中的某个假设函数，$g$则是最接近$f$的那个$h$。</p><h2 id="机器学习真的可行吗？"><a href="#机器学习真的可行吗？" class="headerlink" title="机器学习真的可行吗？"></a>机器学习真的可行吗？</h2><p>我们举个例子：</p><p><img src="https://s2.ax1x.com/2019/06/13/Vfj4oV.png" alt="Vfj4oV.png"></p><a id="more"></a><p>输入特征x是二进制、三维的，对应有8种输入，输出为y。现在假设其中5个为训练样本，有8个hypothesis在训练集D上，对应的输出都完全正确。因此在已知数据D上，$g \approx f$。但是在D以外的另外3个数据集上，我们完全无法预测对应的输出应该是哪个。</p><p>这样看起来我们似乎只能保证在D上有很好的分类效果，机器学习的这种特性又被称为没有免费午餐定理(NFL,No Free Launch)。关于NFL定理：</p><blockquote><p>NFL定理最重要意义是，在脱离实际意义情况下，空泛地谈论哪种算法好毫无意义，要谈论算法优劣必须针对具体学习问题。——百度百科</p></blockquote><p>上面的例子的确很绝望，模型根本没有泛化能力。当然这只是针对这个例子，在研究其他问题时，模型是可以泛化的不错的，接下来就要证明这个。</p><h2 id="推断未知世界"><a href="#推断未知世界" class="headerlink" title="推断未知世界"></a>推断未知世界</h2><p>换一个场景，我们现在在摸球：</p><p><img src="https://s2.ax1x.com/2019/06/13/VfzaL9.png" alt="VfzaL9.png"></p><ul><li>bin为总体，其中$P(\text {orange})=\mu$，$P(\text {green})=1-\mu$。但我们不知道$\mu$具体指。</li><li>sample从bin中提取的样本，样本个数为$N$，其中orange的比例为$\mathcal{V}$，green的比例为$1-\nu$，$\nu$是可以计算的。</li></ul><p>那么$\mu \approx \nu$？在概率论中，需要满足<a href="https://en.wikipedia.org/wiki/Hoeffding&#39;s_inequality" target="_blank" rel="noopener">Hoeffding`s Inequality</a>：</p><p>​                                                                $\mathbb{P}[|\nu-\mu|&gt;\epsilon] \leq 2 \exp \left(-2 \epsilon^{2} N\right)$</p><p>注：$\epsilon$是容忍度，当$\mu$和$\nu$的差别小于容忍度时，我们称$\mu$和$\nu$”差不多“(PAC，Probably approximately correct)。公式中描述的是$\mu$和$\nu$的差别大于容忍度的概率，我们当然希望它越小越好。观察右边发现，$\epsilon^{2}$增大(looser gap)或是$N$增大(增加样本)都能使得概率的上限减小，从而使得$\mu \approx \nu$。</p><h2 id="Connection-to-Learning"><a href="#Connection-to-Learning" class="headerlink" title="Connection to Learning"></a>Connection to Learning</h2><p>我们把learning和抓球问题结合起来。</p><p><img src="https://s2.ax1x.com/2019/06/13/VhAezt.png" alt="VhAezt.png"></p><p>罐子相当于世界上所有有关该问题的<strong>样本空间</strong>，里面的每个球代表着每个样本，从样本中抽取的N个球类比于我们所拥有的<strong>训练样本</strong>。橙色的球代表着用模型预测数据后$h\left(x\right) \neq f\left(x\right)$，绿色的球代表$h\left(x\right)=f\left(x\right)$。根据上一part结论，如果抽样样本N够大，那么就可以从抽样样本中的$h(x) \neq f(x)$的概率来推导<strong>抽样样本以外的所有样本</strong></p><p>$h(x) \neq f(x)$的概率。</p><p>从数学角度上看，这里的$h(x) \neq f(x)$可以看成是一个error，则可以称$h(x)$在sample中出现error的比例记为$E_{i n}$(in-sample-error)，在总体上的error所占比例记为$E_{o u t}$(out-of-sample-error)，则有：</p><p><img src="https://s2.ax1x.com/2019/06/13/VhnXmq.png" alt="VhnXmq.png"></p><p>同样，它的Hoeffding`s Inequality可以表示为：</p><p>$P\left[\left|E_{i n}(h)-E_{o u t}(h)\right|&gt;\epsilon\right] \leq 2 \exp \left(-2 \epsilon^{2} N\right)$</p><p>因此，$E_{i n}(h)$和$E_{o u t}(h)$也满足PAC，这时候机器学习的模型预测会比较准确。</p><p>但这里仅仅针对一个固定的$h$(fixed h)而言，$E_{i n}(h)$和$E_{o u t}(h)$很接近。但这不能说是一个好的learning，因为$E_{in}(h)$可能很大，导致$E_{o u t}(h)$也很大。因此我们的算法$A$应该能从$H$中选择出最好的$h$，记为$g$(final hypothesis)因此需要添加一个验证流程(verification flow)，也就是用非训练集D里的数据来对$h$进行验证。</p><p><img src="https://s2.ax1x.com/2019/06/13/VhQX2F.md.png" alt="VhQX2F.md.png"></p><h2 id="Bad-Sample"><a href="#Bad-Sample" class="headerlink" title="Bad Sample"></a>Bad Sample</h2><p>$A$能够自由在$H$中挑选最合适的$h$，因此每个$h$($h_{1}、h_{2}…$)都有可能成为我们想要的$g$。但是我们的$D$只是来自于总体的一个抽样样本，因此必然存在抽样误差。比如你想知道抛硬币正面的概率，但有时候你连续抛了20次正面，能说明正面的概率为1吗？显然不行，因此这10次硬币，就是一个bad sample。</p><p>或者我们看不同的瓶子：</p><p><img src="https://s2.ax1x.com/2019/06/13/VhDMo8.md.png" alt="VhDMo8.md.png"></p><p>每次的$h$都不相同，而对于$h_{M}$来说，它在抽样数据$D_{M}$上的准确率为100%（都是绿球）。能说明样本空间中绿球的比例是1吗？答案显然是不行。对于learning 而言，其实Bad Sample就是$E_{in}$和$E_{out}$差别很大的情况。</p><p>我们之前说过，Hoeffding’s inequality保证了大多数的$D$都满足$E_{i n} \approx E_{o u t}$。但凡事总有个意外：</p><p><img src="https://s2.ax1x.com/2019/06/13/VhrCXn.md.png" alt="VhrCXn.md.png"></p><p>可以看出，对不同的$D_{n}$和$h_{n}$，都有可能成为Bad Sample，其上界可以表示为连级(union bound)的形式：</p><p><img src="https://s2.ax1x.com/2019/06/13/Vhrt9e.md.png" alt="Vhrt9e.md.png"></p><p>其中M为hypothesis的个数，N是样本$D$的数量，$\epsilon$是容忍度。union bound表明，当M有限，N足够大时。Bad Sample出现的概率比较低。如果这时能找到一个$g$，使得$E_{i n} \approx 0$，PAC就能保证$E_{o u t} \approx 0$。证明机器学习是可行的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="http://beader.me/mlnotebook/section2/is-learning-feasible.html" target="_blank" rel="noopener">机器学习的可行性</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习基石在证明过程中的思想，可以类比于集合论的思想，比如$f$是最完美的模型(函数)，那么$h$是&lt;strong&gt;假设函数空间(hypothesis  set)&lt;/strong&gt;$H$中的某个假设函数，$g$则是最接近$f$的那个$h$。&lt;/p&gt;
&lt;h2 id=&quot;机器学习真的可行吗？&quot;&gt;&lt;a href=&quot;#机器学习真的可行吗？&quot; class=&quot;headerlink&quot; title=&quot;机器学习真的可行吗？&quot;&gt;&lt;/a&gt;机器学习真的可行吗？&lt;/h2&gt;&lt;p&gt;我们举个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/13/Vfj4oV.png&quot; alt=&quot;Vfj4oV.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PLA修正过程</title>
    <link href="http://yoursite.com/2019/06/13/PLA%E4%BF%AE%E6%AD%A3%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/06/13/PLA修正过程/</id>
    <published>2019-06-13T13:51:50.000Z</published>
    <updated>2019-06-13T14:51:27.589Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看<a href="https://www.bilibili.com/video/av12463015/?p=8" target="_blank" rel="noopener">林轩田机器学习基石</a>，作为对ML基础的进一步学习。在2-Learning to Answer Yes_No中，以一个例子来总结解释一下PLA（感知学习算法）的修正过程，以及一些证明。</p><h2 id="PLA"><a href="#PLA" class="headerlink" title="PLA"></a>PLA</h2><p>PLA的主要思想：逐步修正。</p><p>图中坐标原点位于正方形中心位置，样本数据线性可分，决策边界满足$w^{T}x=0$，注意下面谈到的$w$和$x$都是向量。</p><p><strong>step-0</strong>：初始化$w=0$</p><p><img src="https://s2.ax1x.com/2019/06/11/VcQCTg.png" alt="VcQCTg.png"></p><a id="more"></a><p><strong>step-1</strong>：第一次更新，选择样本点$x_{1}$如图所示，记为黑点。更新$w_{t+1}=w_{t}+y*x$，这里圈圈代表y为正，$w_{t}=0$，因此$w_{t+1}=x$。</p><p><img src="https://s2.ax1x.com/2019/06/11/Vcllb8.png" alt="Vcllb8.png"></p><p>又因为$w_{t}x=0$，所以可以画出第一条决策边界如下图。</p><p><strong>step-2</strong>：接下来根据$x_{2}$进行修正，显然它是错误分类的样本点，因此$w_{t}x_{2}&lt;0$，也就是夹角大于90$^{o}$。然后根据上面说的$w$更新规则，可以得到如下图所示紫色的向量$w_{t+1}$，以它作为决策边界的法向量，再次更新决策边界。</p><p><img src="https://s2.ax1x.com/2019/06/11/VclHGd.png" alt="VclHGd.png"></p><p><img src="https://s2.ax1x.com/2019/06/11/Vc1Dyt.png" alt="Vc1Dyt.png"></p><p>之后就是不断循环更新分类错误的点，直到找到合适的分类边界为止。</p><p>但这里还存在一个问题：PLA何时停止？或者说数学上怎样判定找到了合适的分类边界？</p><h2 id="PLA的终止条件"><a href="#PLA的终止条件" class="headerlink" title="PLA的终止条件"></a>PLA的终止条件</h2><p>在线性可分的情况下，假设所有样本正确分类。如果有一条直线，能够将正类和负类完全分开，令这时候的目标权重为$w_{f}$，对于每个点来说，必然满足$y_{n}=\operatorname{sign}\left(w_{f}^{T} x_{n}\right)$，对于任一点：</p><p>$y_{n(t)} \mathbf{w}_{f}^{T} \mathbf{x}_{n(t)} \geq \min _{n} y_{n} \mathbf{w}_{f}^{T} \mathbf{x}_{n}&gt;0$……………………………………………………….(1)</p><p>也就是任一点到分类边界的距离，都大于离分类边界最近点到分类边界的距离。</p><p>上面曾经提到过，PLA是通过逐步修正$w_{t}$，让其逼近$w_{f}$，在数学上体现为$w_{t+1}$和$w_{f}$的内积越来越大，也就是说$\mathbf{w}_{t+1}$和$\mathbf{w}_{f}$之间的夹角要越来越小。因此我们计算：</p><p>$\mathbf{w}_{f}^{T} \mathbf{w}_{t+1}=\mathbf{w}_{f}^{T}\left(\mathbf{w}_{t}+y_{n(t)} \mathbf{x}_{n(t)}\right)\geq\mathbf{w}_{f}^{T} \mathbf{w}_{t}+\min _{n} y_{n} \mathbf{w}_{f}^{T} \mathbf{x}_{n}&gt;\mathbf{w}_{f}^{T} \mathbf{w}_{t}+0$</p><p>可以看出内积的确在增大，但问题是，也有可能是$\mathbf{w}_{t+1}$的模长在增大而并非角度越来越小，因此还需要证明一下$\mathbf{w}_{t+1}$和$\mathbf{w}_{f}$向量长度的关系。首先我们知道：</p><p><img src="https://s2.ax1x.com/2019/06/11/VgPFdP.md.png" alt="VgPFdP.md.png"></p><p>只有当分类错误时，$\mathbf{w}_{t}$才会改变：</p><p>$\operatorname{sign}\left(\mathbf{w}_{t}^{T} \mathbf{x}_{n(t)}\right) \neq y_{n(t)} \Leftrightarrow y_{n(t)} \mathbf{w}_{t}^{T} \mathbf{x}_{n(t)} \leq 0$…………………………………………(2)</p><p>然后计算$\mathbf{w}_{t+1}$的长度，这里我们计算$\left|\mathbf{w}_{t+1}\right|^{2}$，方便很多：</p><p>$\begin{aligned}\left|\mathbf{w}_{t+1}\right|^{2} &amp;=\left|\mathbf{w}_{t}+y_{n(t)} \mathbf{x}_{n(t)}\right|^{2} \\ &amp;=\left|\mathbf{w}_{t}\right|^{2}+2 y_{n(t)} \mathbf{w}_{t}^{T} \mathbf{x}_{n(t)}+\left|y_{n(t)} \mathbf{x}_{n(t)}\right|^{2} \\ &amp; \leq\left|\mathbf{w}_{t}\right|^{2}+0+\left|y_{n(t)} \mathbf{x}_{n(t)}\right|^{2} \\ &amp; \leq\left|\mathbf{w}_{t}\right|^{2}+\max _{n}\left|y_{n} \mathbf{x}_{n}\right|^{2} \end{aligned}$ ……………………………………………..(3)</p><p>因此可以看到长度的增量的限度为：$\max _{n}\left|y_{n} \mathbf{x}_{n}\right|^{2}$。也就是说向量长度的增长非常缓慢，而且有上限。</p><p>至此，我们证明了$\mathbf{w}_{t+1}$的确是在不断逼近$\mathbf{w}_{f}$的，但是要如何证明$\mathbf{w}_{t+1}$何时停止呢？</p><p>这里假设循环次数为$t$，因此我们只需要证明$t$小于某个数即可，而第一步，我们先计算$\mathbf{w}^{T}_{f}$和$\mathbf{w}_{t}$单位向量的内积</p><p>$\frac{w_{f}^{T} }{\left|w_{f}\right|} \frac{w_{t} }{\left|w_{t}\right|}$。根据公式(1)可得：</p><p><img src="https://s2.ax1x.com/2019/06/11/VggQnx.png" alt="VggQnx.png"></p><p>再根据公式(2)可得</p><p><img src="https://s2.ax1x.com/2019/06/11/Vgg8AO.png" alt="Vgg8AO.png"></p><p>(这里的证明其实跟上面几乎是一样的，只是因为要证明的内容不同，所以有些不一样的地方。)</p><p>整理一下可得出结论：</p><p>$\frac{w_{f}^{T} }{\left|w_{f}\right|} \frac{w_{t} }{\left|w_{t}\right|}\geqslant\frac{t \cdot \min y_{n} w_{f}^{T} x_{n} }{\left|w_{f}^{T}\right| \cdot \sqrt{t} \cdot \max _{n}\left|x_{n}\right|}\geq \sqrt{t}\cdot\frac{  \min _{n} y_{n} w_{f}^{T} x_{n} }{\left|w_{f}^{T}\right| \cdot \max _{n}\left|x_{n}\right|}=\sqrt{t}\cdot c$</p><p>(后面的分数等于常数c，因为和$w_{t}$无关)</p><p>$\frac{w_{f}^{T} }{\left|w_{f}\right|} \frac{w_{t} }{\left|w_{t}\right|}$随着迭代次数的增长，会越来越靠近，当完全重合时，内积等于1。因此</p><p>$\frac{w_{f}^{T} }{\left|w_{f}\right|} \frac{w_{t} }{\left|w_{t}\right|}\le1$=&gt;$\sqrt{t} \cdot c\leq1$=&gt;$t\leq\frac{1}{c^{2} }$，存在上界。如果我们做出如下定义：</p><p><img src="https://s2.ax1x.com/2019/06/11/V2CdYT.md.png" alt="V2CdYT.md.png"></p><p>则$t\le \frac{R^{2} }{\rho^{2} }$。</p><h2 id="非线性可分数据"><a href="#非线性可分数据" class="headerlink" title="非线性可分数据"></a>非线性可分数据</h2><p>PLA适用于线性可分的数据，而对于线性不可分数据。PLA可能无法停止。即便是存在个别”噪音“的数据集，PLA都几乎无法工作。因此我们可以PLA修改，得出一个新算法Packet Algorithm。它的算法流程与PLA基本类似，首先初始化权重，计算出在这条初始化的直线中，分类错误点的个数。然后对错误点进行修正，更新w，得到一条新的直线，在计算其对应的分类错误的点的个数，并与之前错误点个数比较，取个数较小的直线作为我们当前选择的分类直线。之后，再经过n次迭代，不断比较当前分类错误点个数与之前最少的错误点个数比较，选择最小的值保存。直到迭代次数完成后，选取个数最少的直线对应的w，即为我们最终想要得到的权重值。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>[1]红色石头的机器学习基石笔记</p><p>链接：<a href="https://pan.baidu.com/s/1uauOV9xyhJkMFao31yWZXg" target="_blank" rel="noopener">https://pan.baidu.com/s/1uauOV9xyhJkMFao31yWZXg</a><br>提取码：kffo </p><p>[2] <a href="https://blog.csdn.net/m0_37411189/article/details/79744912" target="_blank" rel="noopener">感知器学习算法PLA的收敛性证明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看&lt;a href=&quot;https://www.bilibili.com/video/av12463015/?p=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;林轩田机器学习基石&lt;/a&gt;，作为对ML基础的进一步学习。在2-Learning to Answer Yes_No中，以一个例子来总结解释一下PLA（感知学习算法）的修正过程，以及一些证明。&lt;/p&gt;
&lt;h2 id=&quot;PLA&quot;&gt;&lt;a href=&quot;#PLA&quot; class=&quot;headerlink&quot; title=&quot;PLA&quot;&gt;&lt;/a&gt;PLA&lt;/h2&gt;&lt;p&gt;PLA的主要思想：逐步修正。&lt;/p&gt;
&lt;p&gt;图中坐标原点位于正方形中心位置，样本数据线性可分，决策边界满足$w^{T}x=0$，注意下面谈到的$w$和$x$都是向量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step-0&lt;/strong&gt;：初始化$w=0$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/11/VcQCTg.png&quot; alt=&quot;VcQCTg.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Python-for-Data-Analysis|3.2 函数</title>
    <link href="http://yoursite.com/2019/05/15/3-2Functions/"/>
    <id>http://yoursite.com/2019/05/15/3-2Functions/</id>
    <published>2019-05-15T12:46:26.000Z</published>
    <updated>2019-05-15T12:49:11.822Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/05/15/E7phpF.png" alt="E7phpF.png"></p><a id="more"></a><h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><blockquote><p>如果函数不带有返回值，那么会自动返回一个<code>None</code>。</p></blockquote><p>每个函数都含有位置参数和关键字参数，关键字参数通常指明了默认值。下面例子中的<code>z=0.7</code>就是关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">(x, y, z=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> z &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z / (x + y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_function(<span class="number">5</span>, <span class="number">6</span>, z=<span class="number">0.7</span>)</span><br><span class="line">my_function(<span class="number">3.14</span>, <span class="number">7</span>, <span class="number">3.5</span>)</span><br><span class="line">my_function(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><pre><code>45.0</code></pre><h2 id="Namespaces-Scope-and-Local-Functions"><a href="#Namespaces-Scope-and-Local-Functions" class="headerlink" title="Namespaces,Scope,and Local Functions"></a>Namespaces,Scope,and Local Functions</h2><p>在函数体中的变量为局部变量，函数被调用时，局部命名空间(local namespaces)被创建，但函数结束时被释放。</p><h2 id="Returning-Multiple-Values"><a href="#Returning-Multiple-Values" class="headerlink" title="Returning Multiple Values"></a>Returning Multiple Values</h2><p>返回多个值的原理：实际上返回的是一个tuple，这些元组被unpack后赋给不同的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line"></span><br><span class="line">a, b, c = f()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return_value=f()</span><br><span class="line">print(return_value)</span><br></pre></td></tr></table></figure><pre><code>(5, 6, 7)</code></pre><h2 id="Functions-Are-Objects"><a href="#Functions-Are-Objects" class="headerlink" title="Functions Are Objects"></a>Functions Are Objects</h2><p>可以用<strong>列表函数</strong>的方法作用于指定的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">states = [<span class="string">'   Alabama '</span>, <span class="string">'Georgia!'</span>, <span class="string">'Georgia'</span>, <span class="string">'georgia'</span>, <span class="string">'FlOrIda'</span>,</span><br><span class="line">          <span class="string">'south   carolina##'</span>, <span class="string">'West virginia?'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_punctuation</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line"></span><br><span class="line">clean_ops = [str.strip, remove_punctuation, str.title]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings, ops)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean_strings(states,clean_ops)</span><br></pre></td></tr></table></figure><pre><code>[&#39;Alabama&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Florida&#39;, &#39;South   Carolina&#39;, &#39;West Virginia&#39;]</code></pre><p>你可以用函数作为<code>map</code>函数的参数，<code>map</code>的作用是将函数运用到某个序列中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> map(remove_punctuation, states):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><pre><code>   Alabama GeorgiaGeorgiageorgiaFlOrIdasouth   carolinaWest virginia</code></pre><h2 id="Anonymous-Lambda-Functions"><a href="#Anonymous-Lambda-Functions" class="headerlink" title="Anonymous(Lambda) Functions"></a>Anonymous(Lambda) Functions</h2><p><code>lambda</code>关键字除了表示“我们申明了一个匿名函数”之外没有任何其他含义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span><span class="params">(some_list, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> some_list]</span><br><span class="line"></span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><pre><code>[8, 0, 2, 10, 12]</code></pre><h2 id="Currying：Partial-Argument-Application"><a href="#Currying：Partial-Argument-Application" class="headerlink" title="Currying：Partial Argument Application"></a>Currying：Partial Argument Application</h2><p>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。</p><h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><p>用一致的方式在序列中进行迭代，是<code>python</code>的重要特征。这个过程是由迭代协议(<strong>iterator protocol</strong>)，一种原始的使对象迭代的方法。</p><p>关于迭代器更多内容：<a href="https://foofish.net/how-for-works-in-python.html" target="_blank" rel="noopener">for循环在Python中是怎么工作的</a></p><p>生成器延时返回一个序列，每返回一个值便暂停直到下一个值被请求。这和普通函数执行并且返回一个单一的值正好相反。</p><h2 id="Errors-and-Exception-Handing"><a href="#Errors-and-Exception-Handing" class="headerlink" title="Errors and Exception Handing"></a>Errors and Exception Handing</h2><p>python中的<code>float</code>函数用来把一个<code>string</code>类型的值转换成<code>float</code>，注意观察下面的第二个例子中的错误是一<code>ValueError</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float(<span class="string">'1.2345'</span>)</span><br></pre></td></tr></table></figure><pre><code>1.2345</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float(<span class="string">'something'</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-22-2649e4ade0e6&gt; in &lt;module&gt;----&gt; 1 float(&#39;something&#39;)ValueError: could not convert string to float: &#39;something&#39;</code></pre><p>可以用<code>except</code>来处理错误信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attempt_float</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> float(x)</span><br><span class="line">    <span class="keyword">except</span> (ValueError,TypeError):</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>此外还有<code>else</code>：当try的内容成功执行后执行<code>else</code>；<code>finally</code>：无论<code>try</code>是否成功执行，都会执行<code>finally</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/15/E7phpF.png&quot; alt=&quot;E7phpF.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-for-Data-Analysis|3.1数据结构和序列</title>
    <link href="http://yoursite.com/2019/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/15/数据结构和序列/</id>
    <published>2019-05-15T08:43:39.000Z</published>
    <updated>2019-05-15T08:49:00.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Structures-and-Sequences"><a href="#Data-Structures-and-Sequences" class="headerlink" title="Data Structures and Sequences"></a>Data Structures and Sequences</h1><p><img src="https://s2.ax1x.com/2019/05/15/E7phpF.png" alt="E7phpF.png"></p><a id="more"></a><p>从python中基础的数据结构开始：元组(tuple)、列表(list)、字典(dict)和集合(set)</p><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>元组的长度固定，序列不可更多。可以将任何序列或是迭代器转换成元组。</p><p>即便元组存储的是可变对象，一旦元组被创建，可变对象也将变得不可修改。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = tuple([<span class="string">'foo'</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="keyword">True</span>])</span><br><span class="line">tup[<span class="number">2</span>] = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-2-11b694945ab9&gt; in &lt;module&gt;      1 tup = tuple([&#39;foo&#39;, [1, 2], True])----&gt; 2 tup[2] = FalseTypeError: &#39;tuple&#39; object does not support item assignment</code></pre><p>但是如果tuple中的某个元素是可变对象，那么可以修改这个对象中的内容。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup[<span class="number">1</span>].append(<span class="number">3</span>)</span><br><span class="line">tup</span><br></pre></td></tr></table></figure><pre><code>(&#39;foo&#39;, [1, 2, 3], True)</code></pre><h3 id="Unpacking-tuples"><a href="#Unpacking-tuples" class="headerlink" title="Unpacking tuples"></a>Unpacking tuples</h3><p>元组可以解包，即使是嵌套的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup=<span class="number">4</span>,<span class="number">5</span>,(<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">a,b,(c,d)=tup</span><br><span class="line">d</span><br></pre></td></tr></table></figure><pre><code>7</code></pre><p>python允许从元组的开头抓取几个元素，剩余舍去的元素存在<code>rest</code>中，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">values=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></span><br><span class="line">a,b,*rest=values</span><br><span class="line">rest</span><br></pre></td></tr></table></figure><pre><code>[3, 4, 5]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b</span><br></pre></td></tr></table></figure><pre><code>(1, 2)</code></pre><p>可以看出，舍去的元素存储在列表中，抓取的元素存储在元组中</p><h3 id="Tuple-methods"><a href="#Tuple-methods" class="headerlink" title="Tuple methods"></a>Tuple methods</h3><p>鉴于元组的内容不可修改，一个特别有用的方法是<code>count</code>,用来计算某个value出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.count(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><pre><code>4</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="Adding-and-removing-elements"><a href="#Adding-and-removing-elements" class="headerlink" title="Adding and removing elements"></a>Adding and removing elements</h3><p>插入方法有两种：<code>append</code>和<code>insert</code>，其中<code>append</code>在尾部插入而<code>insert</code>可以指定位置插入。</p><blockquote><p><code>insert</code>方法比起<code>append</code>需要花费更多的计算开销，因为任意位置插入需要移动后续的元素。</p></blockquote><p><code>insert</code>的逆运算是<code>pop</code>，它移除并返回指定位置的元素。还可以用<code>remove</code>来去除，它会去除寻找到的第一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b_list=[<span class="string">'foo'</span>,<span class="string">'red'</span>,<span class="string">'baz'</span>,<span class="string">'dwarf'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b_list.append(<span class="string">'foo'</span>)</span><br><span class="line">b_list</span><br></pre></td></tr></table></figure><pre><code>[&#39;foo&#39;, &#39;red&#39;, &#39;baz&#39;, &#39;dwarf&#39;, &#39;foo&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b_list.remove(<span class="string">'foo'</span>)</span><br><span class="line">b_list</span><br></pre></td></tr></table></figure><pre><code>[&#39;red&#39;, &#39;baz&#39;, &#39;dwarf&#39;, &#39;foo&#39;]</code></pre><h3 id="Concatenating-and-combining-lists"><a href="#Concatenating-and-combining-lists" class="headerlink" title="Concatenating and combining lists"></a>Concatenating and combining lists</h3><p>可以用<code>+</code>和<code>extend</code>的方法串联列表，<code>+</code>的计算开销较大，因为需要先创建一个新列表，再将需要串联的两个列表中的元素复制进去。而<code>extend</code>则是在后面追加。</p><h3 id="Binary-search-and-maintaining-a-sorted-list"><a href="#Binary-search-and-maintaining-a-sorted-list" class="headerlink" title="Binary search and maintaining a sorted list"></a>Binary search and maintaining a sorted list</h3><p>内置的<code>bisect</code>模块可以找到插入值的位置，这个值在该位置插入后不会影响排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">bisect.bisect(c, <span class="number">2</span>)</span><br><span class="line">bisect.bisect(c, <span class="number">5</span>)</span><br><span class="line">bisect.insort(c, <span class="number">6</span>)</span><br><span class="line">c</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 2, 2, 3, 4, 6, 7]</code></pre><blockquote><p>需要注意的是，bisec不会去检测列表是否已经有序，因此如果对无序列表进行该操作会引发逻辑错误。</p></blockquote><h3 id="Slicing"><a href="#Slicing" class="headerlink" title="Slicing"></a>Slicing</h3><p>切分后元素的个数可以用stop-start得到。</p><h2 id="Bulid-in-Sequence-Functions"><a href="#Bulid-in-Sequence-Functions" class="headerlink" title="Bulid-in Sequence Functions"></a>Bulid-in Sequence Functions</h2><h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h3><p><code>enumerate</code>枚举可以返回一个字典，其中的key-value对应列表中的元素位置和元素值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_list=[<span class="string">'foo'</span>,<span class="string">'bar'</span>,<span class="string">'baz'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping=&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(some_list):</span><br><span class="line">    mapping[v]=i</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping</span><br></pre></td></tr></table></figure><pre><code>{&#39;foo&#39;: 0, &#39;bar&#39;: 1, &#39;baz&#39;: 2}</code></pre><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted</code>函数排序任意序列的元素值并返回一个<strong>新的排序序列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test=[<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">sorted(test)</span><br></pre></td></tr></table></figure><pre><code>[0, 1, 2, 2, 3, 6, 7]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(test)</span><br></pre></td></tr></table></figure><pre><code>[7, 1, 2, 6, 0, 3, 2]</code></pre><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip可以将多个列表、元组或其它序列成对组合成一个元组列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq1 = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">seq2 = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">zipped = zip(seq1, seq2)</span><br><span class="line">list(zipped)</span><br></pre></td></tr></table></figure><pre><code>[(&#39;foo&#39;, &#39;one&#39;), (&#39;bar&#39;, &#39;two&#39;), (&#39;baz&#39;, &#39;three&#39;)]</code></pre><h3 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h3><blockquote><p>reversed 是一个生成器，只有实体化（即列表或for循环）之后才能创建翻转的序列。</p></blockquote><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>字典也叫哈希表，有key-value形式存储数据。</p><p>可以使用<code>update</code>方法将两个字典混合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1=&#123;<span class="string">'a'</span>:<span class="string">'some value'</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1.update(&#123;<span class="string">'b'</span>:<span class="string">'foo'</span>,<span class="string">'c'</span>:<span class="number">12</span>&#125;)</span><br><span class="line">d1</span><br></pre></td></tr></table></figure><pre><code>{&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: &#39;foo&#39;, &#39;c&#39;: 12}</code></pre><h3 id="Valid-dict-key-types"><a href="#Valid-dict-key-types" class="headerlink" title="Valid dict key types"></a>Valid dict key types</h3><p>字典的key通常是不可修改的对象，行话来说，就是“可哈希性”。你可以通过<code>hash</code>函数来检测是否对象可以被哈希（是否可以被用作key）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">'string'</span>)</span><br></pre></td></tr></table></figure><pre><code>7186817693226238043</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash([<span class="number">1</span>,<span class="number">2</span>])<span class="comment"># list是可修改的值，因此失败。</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-45-9ce67481a686&gt; in &lt;module&gt;----&gt; 1 hash([1,2])TypeError: unhashable type: &#39;list&#39;</code></pre><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code>是无序的不可重复的元素的集合。可以看成是只有key没有value的字典。通用可以有<code>{}</code>创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><pre><code>{1, 2, 3}</code></pre><p>当且仅当集合内容相等是，集合相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;==&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><h2 id="List-Set-and-Dict-Comprehensions"><a href="#List-Set-and-Dict-Comprehensions" class="headerlink" title="List,Set and Dict Comprehensions"></a>List,Set and Dict Comprehensions</h2><p>列表、集合、字典推导式允许用户方便的从一个集合过滤元素，形成列表，在传递参数的过程中还可以修改元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p>等同于for循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Data-Structures-and-Sequences&quot;&gt;&lt;a href=&quot;#Data-Structures-and-Sequences&quot; class=&quot;headerlink&quot; title=&quot;Data Structures and Sequences&quot;&gt;&lt;/a&gt;Data Structures and Sequences&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/15/E7phpF.png&quot; alt=&quot;E7phpF.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter-notebook路径</title>
    <link href="http://yoursite.com/2019/05/13/Jupyter-notebook%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/05/13/Jupyter-notebook路径/</id>
    <published>2019-05-13T12:43:28.000Z</published>
    <updated>2019-05-13T12:54:23.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jupyter-notebook的路径"><a href="#Jupyter-notebook的路径" class="headerlink" title="Jupyter notebook的路径"></a>Jupyter notebook的路径</h3><p>1、你打开jupyter notebook时的路径，即为工作路径。注意下图中的黄色字体部分。<br><img src="https://s2.ax1x.com/2019/05/13/E5DD41.png" alt="E5DD41.png" border="0"></p><a id="more"></a><p>2、注意路径要用斜杠’/‘而不是反斜杠’\\’。</p><h3 id="os-path-join-函数用于路径拼接："><a href="#os-path-join-函数用于路径拼接：" class="headerlink" title="os.path.join()函数用于路径拼接："></a><code>os.path.join()</code>函数用于路径拼接：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">m=os.path.join(<span class="string">'path'</span>,<span class="string">'file_name.txt'</span>)</span><br><span class="line">m</span><br></pre></td></tr></table></figure><pre><code>&#39;path\\file_name.txt&#39;</code></pre><p>可以看到输出的是双反斜杠。而我们需要的是斜杠’/‘</p><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.replace(<span class="string">'\\'</span>,<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure><pre><code>&#39;path/file_name.txt&#39;</code></pre><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m=os.path.join(<span class="string">'path/'</span>,<span class="string">'file_name.txt'</span>)</span><br><span class="line">m</span><br></pre></td></tr></table></figure><pre><code>&#39;path/file_name.txt&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Jupyter-notebook的路径&quot;&gt;&lt;a href=&quot;#Jupyter-notebook的路径&quot; class=&quot;headerlink&quot; title=&quot;Jupyter notebook的路径&quot;&gt;&lt;/a&gt;Jupyter notebook的路径&lt;/h3&gt;&lt;p&gt;1、你打开jupyter notebook时的路径，即为工作路径。注意下图中的黄色字体部分。&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/13/E5DD41.png&quot; alt=&quot;E5DD41.png&quot; border=&quot;0&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="Jupyter notebook" scheme="http://yoursite.com/tags/Jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记|第三周</title>
    <link href="http://yoursite.com/2019/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
    <id>http://yoursite.com/2019/05/08/机器学习笔记-第三周/</id>
    <published>2019-05-08T03:42:21.000Z</published>
    <updated>2019-05-08T03:48:14.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p><img src="https://s2.ax1x.com/2019/05/08/Eyzf58.md.jpg" alt="Eyzf58.md.jpg"></p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/05/08/Eyz4PS.md.jpg" alt="Eyz4PS.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/EyzI2Q.md.jpg" alt="EyzI2Q.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/Eyz7Ks.md.jpg" alt="Eyz7Ks.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/EyzLV0.md.jpg" alt="EyzLV0.md.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逻辑回归&quot;&gt;&lt;a href=&quot;#逻辑回归&quot; class=&quot;headerlink&quot; title=&quot;逻辑回归&quot;&gt;&lt;/a&gt;逻辑回归&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/08/Eyzf58.md.jpg&quot; alt=&quot;Eyzf58.md.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记|第二周</title>
    <link href="http://yoursite.com/2019/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
    <id>http://yoursite.com/2019/05/08/机器学习笔记-第二周/</id>
    <published>2019-05-08T03:35:56.000Z</published>
    <updated>2019-05-08T03:48:05.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多元变量线性回归"><a href="#多元变量线性回归" class="headerlink" title="多元变量线性回归"></a>多元变量线性回归</h2><p><img src="https://s2.ax1x.com/2019/05/08/EyxPSJ.md.jpg" alt="EyxPSJ.md.jpg"></p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/05/08/EyzdUK.md.jpg" alt="EyzdUK.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/Eyz6KA.md.jpg" alt="Eyz6KA.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/Eyzgbt.md.jpg" alt="Eyzgbt.md.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多元变量线性回归&quot;&gt;&lt;a href=&quot;#多元变量线性回归&quot; class=&quot;headerlink&quot; title=&quot;多元变量线性回归&quot;&gt;&lt;/a&gt;多元变量线性回归&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/08/EyxPSJ.md.jpg&quot; alt=&quot;EyxPSJ.md.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记|第一周</title>
    <link href="http://yoursite.com/2019/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>http://yoursite.com/2019/05/08/机器学习笔记-第一周/</id>
    <published>2019-05-08T02:35:39.000Z</published>
    <updated>2019-05-08T03:25:01.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绪论和单变量线性回归"><a href="#绪论和单变量线性回归" class="headerlink" title="绪论和单变量线性回归"></a>绪论和单变量线性回归</h2><p><img src="https://s2.ax1x.com/2019/05/08/EyjKAO.md.jpg" alt="EyjKAO.md.jpg"></p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/05/08/Eyjbb6.md.jpg" alt="Eyjbb6.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/Eyv6RH.md.jpg" alt="Eyv6RH.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/EyvqQs.md.jpg" alt="EyvqQs.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/EyvvwV.md.jpg" alt="EyvvwV.md.jpg"></p><p><img src="https://s2.ax1x.com/2019/05/08/EyxPSJ.md.jpg" alt="EyxPSJ.md.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;绪论和单变量线性回归&quot;&gt;&lt;a href=&quot;#绪论和单变量线性回归&quot; class=&quot;headerlink&quot; title=&quot;绪论和单变量线性回归&quot;&gt;&lt;/a&gt;绪论和单变量线性回归&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/08/EyjKAO.md.jpg&quot; alt=&quot;EyjKAO.md.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>100天机器学习-1</title>
    <link href="http://yoursite.com/2019/05/08/100%E5%A4%A9%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://yoursite.com/2019/05/08/100天机器学习-1/</id>
    <published>2019-05-08T01:56:38.000Z</published>
    <updated>2019-05-08T01:56:38.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day-1"></a>Day-1</h2><h4 id="pd-iloc"><a href="#pd-iloc" class="headerlink" title="pd.iloc()"></a>pd.iloc()</h4><p>用于切分pandas的数据，基于整数位置索引。再通过<code>.values</code>即可返回numpy表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=data.iloc[:,:<span class="number">-1</span>].values</span><br><span class="line">y=data.iloc[:,<span class="number">3</span>].values</span><br></pre></td></tr></table></figure><h4 id="处理缺失值（missing-value）"><a href="#处理缺失值（missing-value）" class="headerlink" title="处理缺失值（missing value）"></a>处理缺失值（missing value）</h4><p>数据集中有些数据的值为<code>NaN</code>。值得一提的是，在numpy中，<code>NaN</code>(Not a Number)属于float类型的。可以使用<code>sklearn.preprocessing</code>中的类<code>Imputer</code>来处理这些缺失值。具体步骤如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创立一个imputer对象，参数是对缺失值的处理方式</span></span><br><span class="line">imputer=Imputer(missing_values=<span class="string">'NaN'</span>,strategy=<span class="string">'mean'</span>,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># fit()方法是用数组x去"训练"imputer对象</span></span><br><span class="line">imputer=imputer.fit(x[:,<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># transform()是用训练好的对象再对x进行处理</span></span><br><span class="line">x[:,<span class="number">1</span>:<span class="number">3</span>]=imputer.transform(x[:,<span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/chaosimple/p/4153158.html" target="_blank" rel="noopener">关于缺失值（missing value）的处理</a></p><h4 id="解析分类数据（encoding-categorical-data）"><a href="#解析分类数据（encoding-categorical-data）" class="headerlink" title="解析分类数据（encoding categorical data）"></a>解析分类数据（encoding categorical data）</h4><p>分类数据是指不用数字而用标签的变量，比如本例中的“Yes”和“No”。为了方便处理，可以用<code>sklearn.preprocessing</code>模块中的<code>LabelEncoder</code>类把他们转换成数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder,OneHotEncoder</span><br><span class="line"></span><br><span class="line">labelencoder_X=LabelEncoder()</span><br><span class="line"><span class="comment"># fit()给标签编码，并且返回编码后的值</span></span><br><span class="line">x[:,<span class="number">0</span>]=labelencoder_X.fit_transform(x[:,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;Day-1&quot;&gt;&lt;/a&gt;Day-1&lt;/h2&gt;&lt;h4 id=&quot;pd-iloc&quot;&gt;&lt;a href=&quot;#pd-iloc&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记|第十周</title>
    <link href="http://yoursite.com/2019/05/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%91%A8/"/>
    <id>http://yoursite.com/2019/05/06/机器学习笔记-第十周/</id>
    <published>2019-05-06T11:02:50.000Z</published>
    <updated>2019-05-06T11:02:50.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大规模机器学习"><a href="#大规模机器学习" class="headerlink" title="大规模机器学习"></a>大规模机器学习</h2><h3 id="学习大数据"><a href="#学习大数据" class="headerlink" title="学习大数据"></a>学习大数据</h3><p>假设我们有一个高偏差模型，那么大规模的数据的确能够帮助你拟合更好的模型。但是大规模的数据可能导致算法运行的效率低下。</p><p>所以在收集大量数据之前，应该考虑用小样本数据是否也能获得较好的拟合效果。</p><a id="more"></a><h3 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h3><p>如果我们确定需要使用到大量数据，也可以使用随机梯度法(<strong>Stochastic gradient descent</strong>)来代替之前提到过的批量梯度下降法(<strong>batch gradient descent</strong>)。</p><p><img src="https://s2.ax1x.com/2019/05/06/EDS5LV.png" alt="EDS5LV.png"></p><p>由图中可知，随机梯度法的代价函数为一个单一训练实例的代价，注意这里取的是一个样本，计算代价：</p><p>​                                                    $cost\left(  \theta, \left( {x}^{(i)} , {y}^{(i)} \right)  \right) = \frac{1}{2}\left( {h}_{\theta}\left({x}^{(i)}\right)-{y}^{ {(i)} } \right)^{2}$</p><p>随机梯度下降的具体步骤：</p><ul><li><p>第一步：随机打乱数据</p></li><li><p>第二步：Repeat (usually anywhere between1-10){</p><p>  <strong>for</strong> $i = 1:m${</p><p> ​       $\theta:={\theta}_{j}-\alpha\left( {h}_{\theta}\left({x}^{(i)}\right)-{y}^{(i)} \right){ {x}_{j} }^{(i)}$      </p><p>​        (<strong>for</strong> $j=0:n$)</p><p> ​    }<br> }</p><p>注意这一步中，对比批量梯度下降法的每次迭代都需要计算所有样本，随机梯度下降法不需要每次迭代（求$\theta$）时都对所有数据累加求平方和，这大大地减少了计算量。</p></li></ul><p>在大样本情况下，随机梯度下降法加大了迭代过程的效率，但同样，它的下降过程不再沿着“正确的方向”，如下图。最终可能无法得到精确的最小值点，而是在最小值值点附近，但对于模型的预测准确度不会有太大的影响。</p><p><img src="https://s2.ax1x.com/2019/05/06/EDpjhQ.png" alt="EDpjhQ.png"></p><h3 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h3><p><img src="https://s2.ax1x.com/2019/05/06/EDCuGQ.png" alt="EDCuGQ.png"></p><p>在每次迭代时，使用b个样本累加求和，具体来说：</p><p> <strong>Repeat</strong> {</p><p> <strong>for</strong> $i = 1:m${</p><p> ​       $\theta:={\theta}_{j}-\alpha\frac{1}{b}\sum_\limits{k=i}^{i+b-1}\left( {h}_{\theta}\left({x}^{(k)}\right)-{y}^{(k)} \right){ {x}_{j} }^{(k)}$      </p><p>​       (<strong>for</strong> $j=0:n$)</p><p>​      $ i +=10 $   </p><p> ​     }<br> }</p><p>通常b的取值在2-100之间。</p><h3 id="随机梯度下降收敛"><a href="#随机梯度下降收敛" class="headerlink" title="随机梯度下降收敛"></a>随机梯度下降收敛</h3><p>随机梯度下降法还有一个好处就是方便观察优化过程中的收敛情况。</p><p><img src="https://s2.ax1x.com/2019/05/06/EDPz1H.png" alt="EDPz1H.png"></p><p>可以看到，批量梯度下降法需要计算完所有的样本才能画出图像，这在大样本的情况下是非常低效的。而随机梯度下降法，只需要每次更新$\theta$之前，计算出代价值。再画出前1000次迭代情况即可。</p><p><img src="https://s2.ax1x.com/2019/05/06/EDiLKs.png" alt="EDiLKs.png"></p><p>前两张图是正确的迭代过程，通常而言，选择样本数量越多，观测到的曲线就越平缓。</p><p>就最后两张图而言，我们可以得出一个结论，如果你得到的曲线没有体现出收敛的趋势（图三），那么可以尝试增加样本，如果还是没有（粉红色线）。那么可能就是特征、算法方面的问题了。</p><p>如果曲线有递增趋势，也就是发散。那么可以尝试使用小一点的学习速率。</p><p>关于学习速率，我们通常是选取固定值。但其实也可以使用变量：$\alpha = \frac{const1}{iterationNumber + const2}$，这可以迫使我们的算法收敛而不是在最小值周围徘徊。但是一般不需要为了学习速率浪费计算资源，我们也可以得到很好的效果。</p><h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><p>如果你有一个连续的用户流引起的数据流，那么就可以设计一个在线学习机制，来根据数据流学习用户的偏好。</p><p>其实这和之前的随机梯度下降主要区别在于，我们的数据是流动的，算法也在不断的学习而不是只用静态的数据集。</p><p> Repeat forever (as long as the website is running) {<br>  Get $\left(x,y\right)$ corresponding to the current user<br>        $\theta:={\theta}_{j}-\alpha\left( {h}_{\theta}\left({x}\right)-{y} \right){ {x}_{j} }$<br>       (<strong>for</strong> $j=0:n$)<br>    }</p><p>一旦(x,y)训练完成，我们就可以抛弃它，因为数据是动态的，还会有新的数据源源不断的输入。</p><h3 id="减少映射与数据并行"><a href="#减少映射与数据并行" class="headerlink" title="减少映射与数据并行"></a>减少映射与数据并行</h3><p>之前我们提到，如果用批量梯度下降法来训练大规模数据是非常耗费时间的，但如果我们能将数据分为多个子集，分给不同的计算机运行，最后再将结果汇总求和，这样的方法就叫做减少映射。</p><p>例如我们有400个例子，需要使用批量梯度下降法，我们可以把数据分配给4台计算机处理：</p><p><img src="https://s2.ax1x.com/2019/05/06/EDllhd.md.png" alt="EDllhd.md.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大规模机器学习&quot;&gt;&lt;a href=&quot;#大规模机器学习&quot; class=&quot;headerlink&quot; title=&quot;大规模机器学习&quot;&gt;&lt;/a&gt;大规模机器学习&lt;/h2&gt;&lt;h3 id=&quot;学习大数据&quot;&gt;&lt;a href=&quot;#学习大数据&quot; class=&quot;headerlink&quot; title=&quot;学习大数据&quot;&gt;&lt;/a&gt;学习大数据&lt;/h3&gt;&lt;p&gt;假设我们有一个高偏差模型，那么大规模的数据的确能够帮助你拟合更好的模型。但是大规模的数据可能导致算法运行的效率低下。&lt;/p&gt;
&lt;p&gt;所以在收集大量数据之前，应该考虑用小样本数据是否也能获得较好的拟合效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记|第九周</title>
    <link href="http://yoursite.com/2019/05/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E5%91%A8/"/>
    <id>http://yoursite.com/2019/05/04/机器学习笔记-第九周/</id>
    <published>2019-05-04T08:50:04.000Z</published>
    <updated>2019-05-04T08:50:04.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h2><p>异常检测(<strong>Anomaly detection</strong>)是一种特殊的无监督学习，但其和监督问题有些类似之处。</p><h3 id="问题动机"><a href="#问题动机" class="headerlink" title="问题动机"></a>问题动机</h3><p>从下图可以看出，对训练集建立模型后，输入$x_{test}$，通过概率来判断它是否异常。</p><p><img src="https://s2.ax1x.com/2019/05/02/EtQyRg.png" alt="EtQyRg.png"></p> <a id="more"></a><p>异常检测的运用：</p><ul><li>欺诈检测</li><li>工业生产领域</li><li>检测数据中心的计算机</li></ul><h3 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h3><p>就是正态分布，因为其性质和异常检测的性质差不多，由下图可以很明显看出，样本集中的位置同样也是高斯分布中概率（面积）较大的位置。</p><p><img src="https://s2.ax1x.com/2019/05/02/EtlNfU.png" alt="EtlNfU.png"></p><p>参数估计要做的则是确定高斯分布的参数，具体而言就是确定$\mu$和$\sigma^{2}$</p><ul><li>均值：$\mu=\frac{1}{m} \sum_{i=1}^{m} x^{(i)}$</li><li>方差：$\sigma^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^{2}$</li></ul><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><ul><li><p>第一步：选取你认为能够指示出异常例子的特征$x_{i}$</p></li><li><p>第二步：拟合参数 $\mu_{1}, \dots, \mu_{n}, \sigma_{1}^{2}, \dots, \sigma_{n}^{2}$</p></li><li><p>第三步：给定一个新的输入，计算$p(x)=\prod_{j=1}^{n} p\left(x_{j} ; \mu_{j}, \sigma_{j}^{2}\right)=\prod_{j=1}^{n} \frac{1}{\sqrt{2 \pi} \sigma_{j}} \exp \left(-\frac{\left(x_{j}-\mu_{j}\right)^{2}}{2 \sigma_{j}^{2}}\right)$</p><p>也就是根据不同的特征，计算出<strong>每个特征的概率</strong>，再将所有概率累乘起来。最后如果$p(x)&lt;\varepsilon$，则标注为异常。</p></li></ul><p>以二维特征为例：</p><p><img src="https://s2.ax1x.com/2019/05/02/EtJiZ9.png" alt="EtJiZ9.png"></p><h3 id="开发和评估异常检测系统"><a href="#开发和评估异常检测系统" class="headerlink" title="开发和评估异常检测系统"></a>开发和评估异常检测系统</h3><p>前面所提到的内容都是在只有正常样本（y=0，normal）的情况下训练的吗，也就是无监督学习。但如果你还有异常样本（y=1，anomalous），则可以用于评估算法的准确性。而且，当为样本选择特征时，如果不确定是否该纳入某一个特征，可以分别在两种情况下进行训练，在验证集上分别评估效果，从而决定是否纳入该特征(模型选择问题)。</p><p>假设现在你有一些带标签数据，即含有正常样本和异常样本。可以把数据集划分为训练集、交叉验证集和测试集。</p><ul><li>数据集尽量都为正常样本</li><li>异常样本放入交叉验证集和测试集中。</li></ul><p>举个例子：飞机引擎，10000个正常引擎，20个有瑕疵的引擎。把正常引擎按60%、20%、20%的比例划分为训练集、CV和测试集。同时把瑕疵引擎平均分配到CV和测试集中。</p><p>用6000个正常引擎数据拟合出概率分布$p(x)$。</p><p><img src="https://s2.ax1x.com/2019/05/02/EtTFi9.png" alt="EtTFi9.png"></p><p>推广到一般情况下</p><p><img src="https://s2.ax1x.com/2019/05/02/Et7u60.png" alt="Et7u60.png"></p><ul><li>利用训练集来拟合出概率分布p(x)</li><li>将CV中的x输入p(x)，设置好阈值$\varepsilon$，从而预测出结果y</li><li>根据y，计算TP、FP、FN、TN。准确率和找回率，计算F1分数</li><li>调整$\varepsilon$直到找到最高F1的函数作为最优拟合模型</li><li>把测试集代入最优拟合模型。</li></ul><h3 id="异常检测-vs-监督学习"><a href="#异常检测-vs-监督学习" class="headerlink" title="异常检测 vs 监督学习"></a>异常检测 vs 监督学习</h3><p>在有标签的情况下，异常检测和监督学习具有相似之处，但仍然有许多明显的差别。从图中可以看出，如果样本中含有大量的负样本（y=0，正常样本），少量正样本（y=1，非正常样本）。那么常使用异常检测；而当正样本数量和负样本数量都很多时，采用监督学习。</p><p><img src="https://s2.ax1x.com/2019/05/03/ENccxe.png" alt="ENccxe.png"></p><p>在用途上也略有不同：</p><p><img src="https://s2.ax1x.com/2019/05/03/ENcvaq.png" alt="ENcvaq.png"></p><h3 id="选择要使用的功能"><a href="#选择要使用的功能" class="headerlink" title="选择要使用的功能"></a>选择要使用的功能</h3><p>在应用异常检测之前，有一个很重要的是就是选择合适的特征。下面介绍几个常用的方法：</p><ul><li>特征不服从高斯分布</li></ul><p><img src="https://s2.ax1x.com/2019/05/03/EN2PtP.png" alt="EN2PtP.png"></p><p>如果特征不服从高斯分布，那就需要通过一些转换方法（比如取对数或是开根号）来构造出符合高斯分布的样子。</p><p><img src="https://s2.ax1x.com/2019/05/03/EN2B9K.png" alt="EN2B9K.png"></p><ul><li>异常检测误差分析</li></ul><p>也可以尝试用有标签的样本，先选择一个比较原始的特征，计算出$p(x)$，在验证集上验证，找到不符合验证结果的样本，观察它的特征，看看能否构建出新的特征，从而能够达到区分的目的。</p><p>例如下图中在只有特征$x_{1}$的情况下，很难看出绿色样本是异常样本。</p><p><img src="https://s2.ax1x.com/2019/05/03/EN2x3T.png" alt="EN2x3T.png"></p><p>此时对可以对这个绿色样本进行分析，看能不能构建出一个特征$x_{2}$，把这个异常样本给检测出来：</p><p><img src="https://s2.ax1x.com/2019/05/03/ENRdbj.png" alt="ENRdbj.png"></p><p>以数据中心的计算机为例：</p><p>通常不会选取值特别大或者特别小的特征。</p><p><img src="https://s2.ax1x.com/2019/05/03/ENWiQS.png" alt="ENWiQS.png"></p><p>如果突然我怀疑一台计算机陷入了死循环，那么$x_{3}$的数值会变得很大而$x_{4}$的数值则基本不变。那么我可以通过设置其它特征$x_{5}$和$x_{6}$来判断是哪台计算机出现了该问题。</p><p><img src="https://s2.ax1x.com/2019/05/03/ENWfl8.png" alt="ENWfl8.png"></p><h3 id="多变量高斯分布"><a href="#多变量高斯分布" class="headerlink" title="多变量高斯分布"></a>多变量高斯分布</h3><p>对比单元高斯分布，多元高斯分布在处理某些问题上具有优势。</p><p>以数据中心的计算机为例：</p><p><img src="https://s2.ax1x.com/2019/05/03/EN5X59.png" alt="EN5X59.png"></p><p>我们用到CPU负载和内存使用两个特征，如果使用单元高斯分布，则分别对这两个特征训练出p(x)，再相乘得到最终结果。反映在左图中，其概率的范围应该是粉红色圈。</p><p>但事实上，我们知道CPU负载和内存的使用之间的关系应该呈现出左图蓝色线圈那样的正线性关系。具体来说，如果此时有一个异常样本点——小绿叉，根据单元高斯分布计算出的结果，小绿叉落在的粉红色线圈范围是概率较高的范围，也就是会被判定为正常样本（从右图也可以看出）。但这显然不符合真实情况。</p><p>要解决这个问题，第一种方法是上一节说过的，可以通过构建新的特征，比如这里可以用x3=x1/x2。还有一种方法就是利用多元高斯分布。</p><p>多元高斯分布考虑了每两个特征之间可能存在的关系。</p><p><img src="https://s2.ax1x.com/2019/05/04/EaFTjP.png" alt="EaFTjP.png"></p><p>而多元高斯分布公式：</p><p><img src="https://s2.ax1x.com/2019/05/04/EaFqHS.png" alt="EaFqHS.png"></p><p>其中，粉色圈内的表示行列式。</p><p>在多元高斯分布公式中，$\Sigma$表示的是协方差矩阵，衡量的是方差，也就是$x_{1}$和$x_{2}$之间的变化量。其中对角线上元素上表示维度之间的方差。</p><p>从下面的图中可以看出，当对角线元素相等时，图像的投影为圆形。而当对角线元素不等时，投影为椭圆。</p><p><img src="https://s2.ax1x.com/2019/05/04/EaFjhj.png" alt="EaFjhj.png"></p><p>非对角的元素表示维度之间的协方差，以下是为正值的情况。</p><p><img src="https://s2.ax1x.com/2019/05/04/EakKu6.png" alt="EakKu6.png"></p><p>如果非对角线的元素为负值：</p><p><img src="https://s2.ax1x.com/2019/05/04/EakNvt.png" alt="EakNvt.png"></p><p>我们还可以改变$\mu$值，即移动峰值所在位置：</p><p><img src="https://s2.ax1x.com/2019/05/04/EakaKP.png" alt="EakaKP.png"></p><h3 id="使用多变量高斯分布的异常检测"><a href="#使用多变量高斯分布的异常检测" class="headerlink" title="使用多变量高斯分布的异常检测"></a>使用多变量高斯分布的异常检测</h3><p>以下是多变量高斯模型的计算过程：</p><p><img src="https://s2.ax1x.com/2019/05/04/EaVmgs.png" alt="EaVmgs.png"></p><p>可以看出计算过程和之前的原始模型（单元高斯分布模型）：</p><p>$p(x)=p\left(x_{1} ; \mu_{1}, \sigma_{1}^{2}\right) \times p\left(x_{2} ; \mu_{2}, \sigma_{2}^{2}\right) \times \cdots \times p\left(x_{n} ; \mu_{n}, \sigma_{n}^{2}\right)$</p><p>有相似的地方。其实只要把多元高斯分布中的$\Sigma$非对角线元素全部改为0，就消除了不同纬度的相关性，得到的就是原始模型了。</p><ul><li>原始模型和多变量高斯分布模型比较</li></ul><p><img src="https://s2.ax1x.com/2019/05/04/EaV1ET.png" alt="EaV1ET.png"></p><p>多元高斯分布模型的优点在于能够自动找到不同维度之间的关系；而原始模型的优点在于计算效率高，适用于维度小或是样本少的情况。值得注意的是多元高斯分布模型的$\Sigma$必须可逆，所以必须满足m&gt;n（NG建议m&gt;=10n），而且维度之间必须是线性无关的。</p><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><h3 id="问题规划"><a href="#问题规划" class="headerlink" title="问题规划"></a>问题规划</h3><p>后面几个小节都会通过这个预测电影评分的例子来讲解，目的是预测左下角表格中’?’的评分</p><p><img src="https://s2.ax1x.com/2019/05/04/EaVbxs.png" alt="EaVbxs.png"></p><h3 id="基于内容的推荐算法"><a href="#基于内容的推荐算法" class="headerlink" title="基于内容的推荐算法"></a>基于内容的推荐算法</h3><p>假设我们已经知道了衡量电影类型的属性，$x_{1}$和$x_{2}$。再添加一个偏置，即可以用三个特征来表示一个样本，例如《Love at last》的特征就是[1 , 0.9 , 0]。</p><p><img src="https://s2.ax1x.com/2019/05/04/Ean0QH.png" alt="Ean0QH.png"></p><p>对于每个样本而言，接下来就需要求出参数$\theta^{(j)}$（单个用户j的参数向量），再通过$\left(\theta^{(j)}\right)^{T} x^{(i)}$即可求出结果。以第一个粉红色圈圈为例，假设我们已知它的参数$\theta^{(1)}$，那么就能预测出评分为4.95。</p><p><img src="https://s2.ax1x.com/2019/05/04/EauE1e.png" alt="EauE1e.png"></p><p>那么如何求出参数$\theta^{(j)}$呢？</p><p>这相当于一个线性回归问题：</p><p><img src="https://s2.ax1x.com/2019/05/04/EauU7q.png" alt="EauU7q.png"></p><p>得到优化目标之后，可以使用梯度下降法、BFGS等方法来进行优化。</p><p><img src="https://s2.ax1x.com/2019/05/04/EaKt2D.png" alt="EaKt2D.png"></p><p>使用基于内容的推荐算法的前提是，我们已经有了用于描述算法的不同特征，这个例子中，就是用了描述电影成分的$x_{1}$和$x_{2}$。但是大多数情况下，我们不具有这些特征时又应该怎么做呢？</p><h3 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h3><p>特征学习：学习算法能自动习得所需要的所有特征。这个和上一节中学习参数$\theta$放在一起，有点类似于先有蛋还是先有鸡的问题。</p><p><img src="https://s2.ax1x.com/2019/05/04/EaQQtx.png" alt="EaQQtx.png"></p><p>从图中可以得出，需要知道每个用户对于不同类型电影的喜爱程度，从而计算出电影含有爱情的成分$x_{1}$和含有动作$x_{2}$的成分。</p><p>对比之前求$\theta$的步骤如下：</p><p><img src="https://s2.ax1x.com/2019/05/04/EaQGcD.png" alt="EaQGcD.png"></p><p>那么到底是先计算$\theta$还是先计算$x_{j}$呢？</p><p>简单来说，就是先猜测一个$\theta$值，然后不断迭代，从而使得参数和特征都收敛于某个最终值。</p><p><img src="https://s2.ax1x.com/2019/05/04/EaQwNt.png" alt="EaQwNt.png"></p><h3 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h3><p>除了上个例子中的反复计算特征和参数的方法，我们还可以把特征和参数放在同一个优化目标中计算。实际操作就是把前面提到的两个优化目标放在一起，因为他们本质上也是针对那些被用户评分了的电影（即r(i,j)=1）。</p><p><img src="https://s2.ax1x.com/2019/05/04/EaYtR1.png" alt="EaYtR1.png"></p><p>值得注意的是，因为协同过滤算法是自动学习参数和特征，所以不需要像以前一样手动去添加偏置项。可以理解为如果算法需要，他会自己去计算出这一项。</p><h3 id="矢量化：低秩矩阵分解"><a href="#矢量化：低秩矩阵分解" class="headerlink" title="矢量化：低秩矩阵分解"></a>矢量化：低秩矩阵分解</h3><p>我们可以把用户对电影的评分的表格记录成矩阵的形式。</p><p><img src="https://s2.ax1x.com/2019/05/04/EagnzT.png" alt="EagnzT.png"></p><p>而我们的预测矩阵应该和矩阵Y中的值差不多</p><p><img src="https://s2.ax1x.com/2019/05/04/Ea25jO.png" alt="Ea25jO.png"></p><p>具体而言，可以把预测矩阵看成是由对每个特征向量转秩后放入矩阵x中，每位用户对某一电影类型的喜好放在矩阵$\Theta$中：</p><p><img src="https://s2.ax1x.com/2019/05/04/EdSRIA.md.png" alt="EdSRIA.md.png"></p><h3 id="实施细节：均值规范化"><a href="#实施细节：均值规范化" class="headerlink" title="实施细节：均值规范化"></a>实施细节：均值规范化</h3><p>如果多了一位用户Eve，她还没对任何电影做出过评分。那么应该如何预测她的评分呢？</p><p><img src="https://s2.ax1x.com/2019/05/04/EdPHlq.png" alt="EdPHlq.png"></p><p>如果我们仍然使用之前说过的方法来计算$\theta$和$x$，那么显然式子中的前两项为0，而只需要最后的正则项，又由于正则化项的性质可知（使得参数接近0），在没有数据时，根本不存在过拟合情况。最后一项中$\theta^{(5)}=0$。再根据$\left(\theta^{(5)}\right)^{T} x^{(i)}=0$可以得到上图中我们对Eve评分的预测值全为0，这显然没有意义。</p><p>为了解决这个问题，我们引入均值化。</p><p><img src="https://s2.ax1x.com/2019/05/04/EdiJAg.png" alt="EdiJAg.png"></p><p>上图中$\mu$为每一行的平均值，再用$Y-\mu$得到右边的矩阵。</p><p>这样在预测评分时，只需要把$\mu$加回去即可，既不会影响已经评分过了的用户，也使得还会评分的用户的预测值不会为0。</p><p><img src="https://s2.ax1x.com/2019/05/04/EdFaIe.png" alt="EdFaIe.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常检测&quot;&gt;&lt;a href=&quot;#异常检测&quot; class=&quot;headerlink&quot; title=&quot;异常检测&quot;&gt;&lt;/a&gt;异常检测&lt;/h2&gt;&lt;p&gt;异常检测(&lt;strong&gt;Anomaly detection&lt;/strong&gt;)是一种特殊的无监督学习，但其和监督问题有些类似之处。&lt;/p&gt;
&lt;h3 id=&quot;问题动机&quot;&gt;&lt;a href=&quot;#问题动机&quot; class=&quot;headerlink&quot; title=&quot;问题动机&quot;&gt;&lt;/a&gt;问题动机&lt;/h3&gt;&lt;p&gt;从下图可以看出，对训练集建立模型后，输入$x_{test}$，通过概率来判断它是否异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/02/EtQyRg.png&quot; alt=&quot;EtQyRg.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习|吴恩达机器学习之PCA</title>
    <link href="http://yoursite.com/2019/05/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BPCA/"/>
    <id>http://yoursite.com/2019/05/02/机器学习-吴恩达机器学习之PCA/</id>
    <published>2019-05-02T06:44:46.000Z</published>
    <updated>2019-05-02T06:44:46.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K-means-Clustering"><a href="#K-means-Clustering" class="headerlink" title="K-means Clustering"></a>K-means Clustering</h2><p>导入模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Implementing-K-means"><a href="#Implementing-K-means" class="headerlink" title="Implementing K-means"></a>Implementing K-means</h3><h4 id="Finding-closet-centroids"><a href="#Finding-closet-centroids" class="headerlink" title="Finding closet centroids"></a>Finding closet centroids</h4><ul><li>读入数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data=loadmat(<span class="string">'ex7data2.mat'</span>)</span><br><span class="line">X=data[<span class="string">'X'</span>]</span><br></pre></td></tr></table></figure><ul><li>为每个样本找到最近的聚类中心</li></ul><p>$c^{(i)} :=j \quad$ that minimizes $\quad\left|x^{(i)}-\mu_{j}\right|^{2}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#========================找聚类中心</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closet_centroids</span><span class="params">(X,centroids)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    返回每个样本所在的cluster索引</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    idx=[]</span><br><span class="line">    max_dist=<span class="number">10000</span> <span class="comment"># 给一个距离限定</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        minus=X[i]-centroids <span class="comment"># minus是3x2的矩阵，每一行代表了第i个样本到一个centroids的x1,x2距离</span></span><br><span class="line">        dist=minus[:,<span class="number">0</span>]**<span class="number">2</span>+minus[:,<span class="number">1</span>]**<span class="number">2</span> <span class="comment">#求范式，即直线距离,dist是3x1的向量</span></span><br><span class="line">        <span class="keyword">if</span> dist.min()&lt;max_dist:</span><br><span class="line">            ci=np.argmin(dist) <span class="comment">#返回沿axis的最小值索引</span></span><br><span class="line">            idx.append(ci)</span><br><span class="line">    <span class="keyword">return</span> np.array(idx)</span><br></pre></td></tr></table></figure><p>可以自己初始化一组聚类中心来测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_centroids = np.array([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">2</span>], [<span class="number">8</span>, <span class="number">5</span>]])</span><br><span class="line">idx = findClosestCentroids(X, init_centroids)</span><br><span class="line">print(idx[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>结果应该是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="Computing-centroids-means"><a href="#Computing-centroids-means" class="headerlink" title="Computing  centroids means"></a>Computing  centroids means</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=========================移动聚类中心</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_centroids</span><span class="params">(X,idx)</span>:</span></span><br><span class="line">    centroids=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(np.unique(idx))):</span><br><span class="line">        <span class="comment"># 布尔索引，idx==i运算返回bool value，根据值为true的下标来输出X中对应元素值</span></span><br><span class="line">        u_k=X[idx==i].mean(axis=<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        centroids.append(u_k)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> np.array(centroids)</span><br></pre></td></tr></table></figure><h4 id="K-means-on-example-dataset"><a href="#K-means-on-example-dataset" class="headerlink" title="K-means on example dataset"></a>K-means on example dataset</h4><ul><li>画图函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_data</span><span class="params">(X,centroids,idx=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    colors = [<span class="string">'b'</span>,<span class="string">'g'</span>,<span class="string">'gold'</span>,<span class="string">'darkorange'</span>,<span class="string">'salmon'</span>,<span class="string">'olivedrab'</span>, </span><br><span class="line">              <span class="string">'maroon'</span>, <span class="string">'navy'</span>, <span class="string">'sienna'</span>, <span class="string">'tomato'</span>, <span class="string">'lightgray'</span>, <span class="string">'gainsboro'</span></span><br><span class="line">             <span class="string">'coral'</span>, <span class="string">'aliceblue'</span>, <span class="string">'dimgray'</span>, <span class="string">'mintcream'</span>, <span class="string">'mintcream'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里centroids需要从ndarray转成list,但centroids[0]仍为ndarray.</span></span><br><span class="line">    <span class="keyword">assert</span> len(centroids[<span class="number">0</span>])&lt;=len(colors),<span class="string">'colors not enough'</span> </span><br><span class="line">    </span><br><span class="line">    subX=[]</span><br><span class="line">    <span class="keyword">if</span> idx <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(centroids[<span class="number">0</span>].shape[<span class="number">0</span>]): <span class="comment">#分成几类就循环几次</span></span><br><span class="line">            x_i=X[idx==i]</span><br><span class="line">            subX.append(x_i) <span class="comment">#把数据按cluster分成不同下标的元素，存储在subx这个list中</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        subX=[X]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fig=plt.figure(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(subX)):</span><br><span class="line">        xx=subX[i]</span><br><span class="line">        plt.scatter(xx[:,<span class="number">0</span>],xx[:,<span class="number">1</span>],c=colors[i])    </span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line">    plt.title(<span class="string">'Plot of X Points'</span>)</span><br><span class="line"></span><br><span class="line">    xx,yy=[],[]</span><br><span class="line">    <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids: </span><br><span class="line">        xx.append(centroid[:,<span class="number">0</span>])</span><br><span class="line">        yy.append(centroid[:,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    plt.plot(xx,yy,<span class="string">'rx--'</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><ul><li>画出聚类中心移动过程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============================聚类中心移动过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_kmeans</span><span class="params">(X,centroids,max_iters)</span>:</span></span><br><span class="line"></span><br><span class="line">    centroids_all=[]</span><br><span class="line">    centroids_all.append(centroids)</span><br><span class="line">    centroid_i=centroids</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_iters):</span><br><span class="line">        idx=find_closet_centroids(X,centroid_i)</span><br><span class="line">        centroid_i=compute_centroids(X,idx) </span><br><span class="line">        centroids_all.append(centroid_i) <span class="comment">#每次移动后的聚类中心坐标都记录下来</span></span><br><span class="line">    <span class="keyword">return</span> idx,centroids_all</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://s2.ax1x.com/2019/05/02/EYOrCQ.png" alt="EYOrCQ.png"></p><h4 id="Random-initialization"><a href="#Random-initialization" class="headerlink" title="Random initialization"></a>Random initialization</h4><p>关于聚类中心的初始化，一个更好的方法是从样本集中随机选取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#==============================随机初始化聚类中心</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_centroids</span><span class="params">(X,K)</span>:</span></span><br><span class="line">    m=X.shape[<span class="number">0</span>]</span><br><span class="line">    index=np.random.choice(m,K) <span class="comment">#在0~m中随机生成K个样本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X[index]</span><br></pre></td></tr></table></figure><p>最后再尝试一下聚类算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        init_centroids=random_centroids(X,<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        idx,centroids_all=run_kmeans(X,init_centroids,<span class="number">20</span>)</span><br><span class="line">        plot_data(X,centroids_all,idx=idx) <span class="comment">#idx为每个样本所在cluster的索引</span></span><br></pre></td></tr></table></figure><p>得到最终结果：</p><p><img src="https://s2.ax1x.com/2019/05/02/EYXtG4.md.png" alt="EYXtG4.md.png"></p><h3 id="Image-compression-with-K-means"><a href="#Image-compression-with-K-means" class="headerlink" title="Image compression with K-means"></a>Image compression with K-means</h3><ul><li>导入数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img=io.imread(<span class="string">'bird_small.png'</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br><span class="line">print(img.shape)</span><br></pre></td></tr></table></figure><p>图像为</p><p><img src="https://s2.ax1x.com/2019/05/02/EYX5eP.png" alt="EYX5eP.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">128</span>,<span class="number">128</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>可以看到图像以3维矩阵的方式存储，前面两个维度代表图像的像素点个数128x128，最后一个维度代表像素点由RGB三个通道表示。又因为一个通道占用8-bit，因此在原始的图像中一个像素点需要24-bit来储存。</p><p>在这幅图中包含了上千种种颜色，而在这个实验中，我们把颜色降为16种，也就是说，一像素点只需要4bit就足够了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img=img/<span class="number">255</span></span><br><span class="line">X=img.reshape(<span class="number">-1</span>,<span class="number">3</span>) <span class="comment">#转换成128x128行，3列为RGB三通道</span></span><br><span class="line">K=<span class="number">16</span> <span class="comment">#16个聚类中心，就是把所有颜色压缩为16种RGB颜色，那么每个像素值需要4bit存储即可</span></span><br><span class="line">init_centroids=random_centroids(X,K)</span><br><span class="line">idx,centroids_all=run_kmeans(X,init_centroids,<span class="number">10</span>)</span><br><span class="line">img_2=np.zeros(X.shape)</span><br><span class="line">centroids=centroids_all[<span class="number">-1</span>] <span class="comment"># 只需要记录聚类中心最后移动的位置即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(centroids)):</span><br><span class="line">    img_2[idx==i]=centroids[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img_2=img_2.reshape((<span class="number">128</span>,<span class="number">128</span>,<span class="number">3</span>))</span><br><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line">axes[<span class="number">0</span>].imshow(img)</span><br><span class="line">axes[<span class="number">1</span>].imshow(img_2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>比对一下压缩效果：</p><p><img src="https://s2.ax1x.com/2019/05/02/EYjBlj.md.png" alt="EYjBlj.md.png"></p><h2 id="Principle-Component-Analysis"><a href="#Principle-Component-Analysis" class="headerlink" title="Principle Component Analysis"></a>Principle Component Analysis</h2><ul><li>导入模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br></pre></td></tr></table></figure><h3 id="Example-Dataset"><a href="#Example-Dataset" class="headerlink" title="Example Dataset"></a>Example Dataset</h3><ul><li>导入数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = loadmat(<span class="string">'ex7data1.mat'</span>)</span><br><span class="line">X = data[<span class="string">'X'</span>]</span><br><span class="line">print(X.shape)</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>], X[:,<span class="number">1</span>], facecolors=<span class="string">'none'</span>, edgecolors=<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(50,2)</span><br></pre></td></tr></table></figure><ul><li>显示图像：</li></ul><p><img src="https://s2.ax1x.com/2019/05/02/EYz5cQ.png" alt="EYz5cQ.png"></p><h3 id="Implementing-PCA"><a href="#Implementing-PCA" class="headerlink" title="Implementing PCA"></a>Implementing PCA</h3><blockquote><p>关于PCA的数学原理可以参考：<a href="https://nullblog.top/2019/05/01/%E6%B5%85%E8%B0%88SVD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">浅谈SVD的数学原理及应用</a></p></blockquote><p>PCA主要分为两个计算步骤：</p><ul><li>计算数据的协方差矩阵：$\Sigma=\frac{1}{m} \sum_{i=1}^{n}\left(x^{(i)}\right)\left(x^{(i)}\right)^{T}$</li><li>用SVD函数进行奇异值分解</li></ul><p>在开始上面的步骤之前，需要先对数据进行特征缩放和归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_normalize</span><span class="params">(X)</span>:</span></span><br><span class="line">    means = X.mean(axis=<span class="number">0</span>)</span><br><span class="line">    stds = X.std(axis=<span class="number">0</span>, ddof=<span class="number">1</span>)</span><br><span class="line">    X_norm = (X - means) / stds</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_norm, means</span><br></pre></td></tr></table></figure><p>PCA：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#===================================PCA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(X)</span>:</span></span><br><span class="line">    sigma = (<span class="number">1</span> / len(X)) * (X.T @ X)  <span class="comment">#求出协方差矩阵</span></span><br><span class="line">    U, S, V = np.linalg.svd(sigma)  <span class="comment">#奇异值分解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> U, S, V</span><br></pre></td></tr></table></figure><p>可视化主成成分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_reduce</span><span class="params">(means, U, S)</span>:</span></span><br><span class="line">    plt.plot([means[<span class="number">0</span>], means[<span class="number">0</span>] + <span class="number">1.5</span> * S[<span class="number">0</span>] * U[<span class="number">0</span>, <span class="number">0</span>]],</span><br><span class="line">             [means[<span class="number">1</span>], means[<span class="number">1</span>] + <span class="number">1.5</span> * S[<span class="number">0</span>] * U[<span class="number">0</span>, <span class="number">1</span>]],</span><br><span class="line">             c=<span class="string">'r'</span>,</span><br><span class="line">             linewidth=<span class="number">3</span>,</span><br><span class="line">             label=<span class="string">'First Principle Component'</span>)</span><br><span class="line">    plt.plot([means[<span class="number">0</span>], means[<span class="number">0</span>] + <span class="number">1.5</span> * S[<span class="number">1</span>] * U[<span class="number">1</span>, <span class="number">0</span>]],</span><br><span class="line">             [means[<span class="number">1</span>], means[<span class="number">1</span>] + <span class="number">1.5</span> * S[<span class="number">1</span>] * U[<span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">             c=<span class="string">'g'</span>,</span><br><span class="line">             linewidth=<span class="number">3</span>,</span><br><span class="line">             label=<span class="string">'Second Principal Component'</span>)</span><br><span class="line">    plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">    plt.legend()</span><br></pre></td></tr></table></figure><p>得到结果：</p><p><img src="https://s2.ax1x.com/2019/05/02/EtpMM4.md.png" alt="EtpMM4.md.png"></p><h3 id="Dimensionality-Reduction-with-PCA"><a href="#Dimensionality-Reduction-with-PCA" class="headerlink" title="Dimensionality Reduction with PCA"></a>Dimensionality Reduction with PCA</h3><h4 id="Projecting-the-data-onto-the-principal-components"><a href="#Projecting-the-data-onto-the-principal-components" class="headerlink" title="Projecting the data onto the principal components"></a>Projecting the data onto the principal components</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">返回值</span></span><br><span class="line"><span class="string">- Z：投影到主成成分后的样本点</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">project_data</span><span class="params">(X, U, K)</span>:</span></span><br><span class="line">    Z = X @ U[:, <span class="number">0</span>:K]</span><br><span class="line">    <span class="keyword">return</span> Z</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">K = <span class="number">1</span></span><br><span class="line">Z = project_data(X_norm, U, K)</span><br><span class="line">print(Z[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">1.48127391</span>])</span><br></pre></td></tr></table></figure><h4 id="Reconstructing-an-approximation-of-the-data"><a href="#Reconstructing-an-approximation-of-the-data" class="headerlink" title="Reconstructing an approximation of the data"></a>Reconstructing an approximation of the data</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#===================================重建数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_data</span><span class="params">(Z, U, K)</span>:</span></span><br><span class="line">    X_rec = Z @ U[:, <span class="number">0</span>:K].T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_rec</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># you will recover an approximation of the first example and you should see a value of</span></span><br><span class="line"><span class="comment"># about [-1.047 -1.047].</span></span><br><span class="line">X_rec = recover_data(Z, U, <span class="number">1</span>)</span><br><span class="line">X_rec[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">-1.04741883</span>, <span class="number">-1.04741883</span>])</span><br></pre></td></tr></table></figure><h4 id="Visualizing-the-projections"><a href="#Visualizing-the-projections" class="headerlink" title="Visualizing the projections"></a>Visualizing the projections</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#====================================PCA样本投影可视化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_data</span><span class="params">(X_norm, X_rec)</span>:</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line">    plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">    plt.scatter(</span><br><span class="line">        X_norm[:, <span class="number">0</span>],</span><br><span class="line">        X_norm[:, <span class="number">1</span>],</span><br><span class="line">        s=<span class="number">30</span>,</span><br><span class="line">        facecolors=<span class="string">'none'</span>,</span><br><span class="line">        edgecolors=<span class="string">'blue'</span>,</span><br><span class="line">        label=<span class="string">'Original Data Points'</span>)</span><br><span class="line"></span><br><span class="line">    plt.scatter(</span><br><span class="line">        X_rec[:, <span class="number">0</span>],</span><br><span class="line">        X_rec[:, <span class="number">1</span>],</span><br><span class="line">        s=<span class="number">30</span>,</span><br><span class="line">        facecolors=<span class="string">'none'</span>,</span><br><span class="line">        edgecolors=<span class="string">'red'</span>,</span><br><span class="line">        label=<span class="string">'PCA Reduced Data Points'</span>)</span><br><span class="line"></span><br><span class="line">    plt.title(<span class="string">"Example Dataset: Reduced Dimension Points Shown"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'x1 [Feature Normalized]'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'x2 [Feature Normalized]'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(X_norm.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.plot([X_norm[x,<span class="number">0</span>],X_rec[x,<span class="number">0</span>]],[X_norm[x,<span class="number">1</span>],X_rec[x,<span class="number">1</span>]],<span class="string">'k--'</span>)</span><br><span class="line">        plt.legend(loc=<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 输入第一项全是X坐标，第二项都是Y坐标</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://s2.ax1x.com/2019/05/02/Et9DcF.md.png" alt="Et9DcF.md.png"></p><h3 id="Face-Image-Dataset"><a href="#Face-Image-Dataset" class="headerlink" title="Face Image Dataset"></a>Face Image Dataset</h3><ul><li>导入数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_2=loadmat(<span class="string">'ex7faces.mat'</span>)</span><br><span class="line">X_2=data_2[<span class="string">'X'</span>]</span><br></pre></td></tr></table></figure><ul><li>数据可视化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_face</span><span class="params">(X,row,col)</span>:</span></span><br><span class="line">    fig,ax=plt.subplots(row,col,figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            ax[i][j].imshow(X[i*col+j].reshape(<span class="number">32</span>,<span class="number">32</span>).T,cmap=<span class="string">'Greys_r'</span>)</span><br><span class="line">            ax[i][j].set_xticks([])</span><br><span class="line">            ax[i][j].set_yticks([])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://s2.ax1x.com/2019/05/02/Et9Ije.png" alt="Et9Ije.png"></p><h4 id="PCA-on-Faces"><a href="#PCA-on-Faces" class="headerlink" title="PCA on Faces"></a>PCA on Faces</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_2_norm,means_2=feature_normalize(X_2)</span><br><span class="line">U_2,S_2,V_2=pca(X_2_norm)</span><br></pre></td></tr></table></figure><p>显示主成成分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_face(U[:,:<span class="number">36</span>].T, <span class="number">6</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.ax1x.com/2019/05/02/Et9O4P.png" alt="Et9O4P.png"></p><h4 id="Dimensionality-Reduction"><a href="#Dimensionality-Reduction" class="headerlink" title="Dimensionality Reduction"></a>Dimensionality Reduction</h4><p>把图片降维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z_2=project_data(X_2_norm,U_2,K=<span class="number">36</span>)</span><br><span class="line">X_2_rec=recover_data(Z_2,U_2,K=<span class="number">36</span>)</span><br><span class="line">plot_face(X_2_rec,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://s2.ax1x.com/2019/05/02/Etn09H.png" alt="Etn09H.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;K-means-Clustering&quot;&gt;&lt;a href=&quot;#K-means-Clustering&quot; class=&quot;headerlink&quot; title=&quot;K-means Clustering&quot;&gt;&lt;/a&gt;K-means Clustering&lt;/h2&gt;&lt;p&gt;导入模块&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scipy.io &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; loadmat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; skimage &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; io&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>浅谈SVD的数学原理及应用</title>
    <link href="http://yoursite.com/2019/05/01/%E6%B5%85%E8%B0%88SVD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/01/浅谈SVD的数学原理及应用/</id>
    <published>2019-05-01T07:02:06.000Z</published>
    <updated>2019-05-01T11:13:56.918Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在做PCA的实验时，遇到的SVD奇异值分解问题，这里记录自己直观的理解</p></blockquote><p>通常在<code>python</code>中我们都是直接调用<code>numpy</code>模块中的函数，那么返回的U,S,V几个值代表什么意思呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U, S, V = np.linalg.svd(X)</span><br></pre></td></tr></table></figure><p>遇事不明，手册先行：<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.svd.html" target="_blank" rel="noopener">官方手册</a></p><a id="more"></a><p>手册中简单说明了其含义：</p><ul><li>U：酉矩阵</li><li>S：奇异值向量（数学上是奇异值矩阵，但因为这个矩阵类似于对角阵，只有主对角线上的元素非0，程序对其进行了处理，直接提取了对角元素），且元素按降序排列。</li><li>V：酉矩阵</li></ul><p>首先给出SVD分解公式：$W=U \Sigma V^{T}$</p><p>如果你看的一脸懵逼，没关系，这只能说明你和我一样，线性代数没怎么学好。所以接下来简单解释一下其背后的数学原理，希望有帮助。</p><p>举一个具体分解的例子：</p><p>有这么一个矩阵：$W=\left[ \begin{array}{ll}{1} &amp; {1} \\ {0} &amp; {1} \\ {1} &amp; {0}\end{array}\right]$我们要如何把它SVD分解？</p><p><strong>step-1.1</strong> </p><p>计算第一个对角矩阵，$C=W^{T} W=\left[ \begin{array}{lll}{1} &amp; {0} &amp; {1} \\ {1} &amp; {1} &amp; {0}\end{array}\right] \left[ \begin{array}{ll}{1} &amp; {1} \\ {0} &amp; {1} \\ {1} &amp; {0}\end{array}\right]=\left[ \begin{array}{ll}{2} &amp; {1} \\ {1} &amp; {2}\end{array}\right]$，注意得到的是方阵。</p><p><strong>step-1.2</strong></p><p>接着对这个对角矩阵，求它的特征值$\lambda_{1}=3, \lambda_{2}=1$和特征向量$\vec{v}_{1}=\left[ \begin{array}{l}{\frac{1}{\sqrt{2}}} \\ {\frac{1}{\sqrt{2}}}\end{array}\right], \vec{v}_{2}=\left[ \begin{array}{l}{\frac{1}{\sqrt{2}}} \\ {\frac{-1}{\sqrt{2}}}\end{array}\right]$。</p><p><strong>step-2.1</strong></p><p>计算第二个对角矩阵，$B=W W^{T}=\left[ \begin{array}{ll}{1} &amp; {1} \\ {0} &amp; {1} \\ {1} &amp; {0}\end{array}\right] \left[ \begin{array}{lll}{1} &amp; {0} &amp; {1} \\ {1} &amp; {1} &amp; {0}\end{array}\right]=\left[ \begin{array}{lll}{2} &amp; {1} &amp; {1} \\ {1} &amp; {1} &amp; {0} \\ {1} &amp; {0} &amp; {1}\end{array}\right]$，和step-1.1比起来，能看到区别在于$W^{T}W$和$WW^{T}$。</p><p><strong>step-2.2</strong></p><p>同样，求它的特征值$\lambda_{1}=3, \lambda_{2}=1, \lambda_{3}=0$和特征向量$\vec{u}_{1}=\left[ \begin{array}{c}{\frac{2}{\sqrt{6} } } \\ {\frac{1}{\sqrt{6} } } \\ {\frac{1}{\sqrt{6} } }\end{array}\right], \vec{u}_{2}=\left[ \begin{array}{c}{0} \\ {\frac{-1}{\sqrt{2} } } \\ {\frac{1}{\sqrt{2} } }\end{array}\right], \vec{u}_{3}=\left[ \begin{array}{c}{\frac{-1}{\sqrt{3} } } \\ {\frac{1}{\sqrt{3} } } \\ {\frac{1}{\sqrt{3} } }\end{array}\right]$。</p><p>最终我们根据公式：$W=U \Sigma V^{T}$，就可以得到</p><p>$W=\left[ \begin{array}{ll}{1} &amp; {1} \\ {0} &amp; {1} \\ {1} &amp; {0}\end{array}\right]=\left[ \begin{array}{ccc}{\frac{2}{\sqrt{6}}} &amp; {0} &amp; {-\frac{1}{\sqrt{3}}} \\ {\frac{1}{\sqrt{6}}} &amp; {\frac{-1}{\sqrt{2}}} &amp; {\frac{1}{\sqrt{3}}} \\ {\frac{1}{\sqrt{6}}} &amp; {\frac{1}{\sqrt{2}}} &amp; {\frac{1}{\sqrt{3}}}\end{array}\right] \left[ \begin{array}{cc}{\sqrt{3}} &amp; {0} \\ {0} &amp; {1} \\ {0} &amp; {0}\end{array}\right] \left[ \begin{array}{cc}{\frac{1}{\sqrt{2}}} &amp; {\frac{1}{\sqrt{2}}} \\ {\frac{1}{\sqrt{2}}} &amp; {\frac{-1}{\sqrt{2}}}\end{array}\right]$</p><p>其中$U$就是$B$的特征向量拼成的酉矩阵，$V^{T}$就是$C$的特征向量拼成的酉矩阵。而$\Sigma$(即S)就是由<strong>特征值开根号</strong>得到的。</p><p>我们还可以把上面的矩阵写成另外的表达方式：</p><p>$W=\sqrt{3} \left[ \begin{array}{c}{\frac{2}{\sqrt{6}}} \\ {\frac{1}{\sqrt{6}}} \\ {\frac{1}{\sqrt{6}}}\end{array}\right] \left[ \begin{array}{cc}{\frac{1}{\sqrt{2}}} &amp; {\frac{1}{\sqrt{2}}}\end{array}\right]+\left[ \begin{array}{c}{0} \\ {-\frac{1}{\sqrt{2}}} \\ {\frac{1}{\sqrt{2}}}\end{array}\right] \left[ \begin{array}{cc}{\frac{1}{\sqrt{2}}} &amp; {\frac{-1}{\sqrt{2}}}\end{array}\right]$</p><p>也就是$W=\sqrt\lambda_{1}\vec{u}_{1}\left(\vec{v}_{1}\right)^{T}+\sqrt\lambda_{2}\vec{u}_{2}\left(\vec{v}_{2}\right)^{T}$。再说一次，<strong>奇异值的平方=特征值</strong>。</p><p>这样也就可以解释为什么SVD会被用于PCA，实际上我们只是举了很简单的例子，当矩阵的维数更高时，我们最后得到的式子的项数也就越多，但是有些项数的奇异值很小，舍去这些项虽然会丢失局部细节，但是能够在尽量保真的情况下节约存储空间。</p><p><strong>参考资料：</strong></p><p>[1] <a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="noopener">机器学习中的数学(5)-强大的矩阵奇异值分解(SVD)及其应用</a></p><p>[2] <a href="https://blog.csdn.net/u012162613/article/details/42214205" target="_blank" rel="noopener">【简化数据】奇异值分解(SVD)</a> </p><p>[3] <a href="https://www.bilibili.com/video/av15971352/?p=3" target="_blank" rel="noopener">矩阵分析之奇异值分解（SVD）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在做PCA的实验时，遇到的SVD奇异值分解问题，这里记录自己直观的理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常在&lt;code&gt;python&lt;/code&gt;中我们都是直接调用&lt;code&gt;numpy&lt;/code&gt;模块中的函数，那么返回的U,S,V几个值代表什么意思呢？&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;U, S, V = np.linalg.svd(X)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;遇事不明，手册先行：&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.svd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方手册&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记-第八周</title>
    <link href="http://yoursite.com/2019/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E5%91%A8/"/>
    <id>http://yoursite.com/2019/04/29/机器学习笔记-第八周/</id>
    <published>2019-04-29T03:55:29.000Z</published>
    <updated>2019-04-29T04:02:11.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="无监督学习-1"><a href="#无监督学习-1" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>之间学习的都是监督学习，也就是样本都有标签。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMlktI.png" alt="EMlktI.png"></p><a id="more"></a><p>而无监督学习的样本是没有标签的，也就是只有输入x，没有输出标记。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMllAs.md.png" alt="EMllAs.md.png"></p><p>无监督学习就是找到隐含在这类无标签数据中的结构，这类算法称为聚类算法（<strong>clustering algorithm</strong>）。</p><h3 id="K-Means算法"><a href="#K-Means算法" class="headerlink" title="K-Means算法"></a>K-Means算法</h3><p>k均值算法，先随机生成两个数据，即聚类中心（<strong>cluster centroids</strong>）。</p><p><img src="https://s2.ax1x.com/2019/04/28/EM1lrD.md.png" alt="EM1lrD.md.png"></p><p>然后遍历所有数据，和蓝色聚类中心靠近的，就渲染为蓝色；和红色聚类中心靠近的，就渲染为红色。然后移动聚类中心到同颜色点的均值处。</p><p><img src="https://s2.ax1x.com/2019/04/28/EM1Bqg.png" alt="EM1Bqg.png"></p><p>重复上述步骤，直到聚类完成，聚类中心不再变化，样本的分类也不再变化。</p><p><img src="https://s2.ax1x.com/2019/04/28/EM14LF.png" alt="EM14LF.png"></p><p>通过图像我们可以直观的了解到，使用K均值算法聚类，输入需要样本特征$x^{(i)}$和聚类中心数K。</p><p>具体步骤如下：</p><p><img src="https://s2.ax1x.com/2019/04/28/EM8ObD.png" alt="EM8ObD.png"></p><p>循环1是根据聚类中心分类，循环2是根据平均值移动聚类中心。其中$c^{(i)}$表示的是$x^{(i)}$到不同聚类中心，距离最小的那个的聚类中心的索引值。</p><p>有时候数据的分类不那么明确，比如T-shirt的尺寸。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMGLzq.png" alt="EMGLzq.png"></p><p>同样也可以用K均值算法进行聚类。将T-shirt的尺寸根据身高和体重，分类为S、M、L。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMGvLT.png" alt="EMGvLT.png"></p><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>K均值算法同样有优化目标，或者说代价函数（这里也叫畸变函数）。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMNc0f.png" alt="EMNc0f.png"></p><p>代价函数就是样本到聚类中心距离的平方和，而优化目标就是找到代价函数值最小时的$c^{(i)}$和聚类中心$\mu_{k}$，从下图也可以看出两个循环就是为了得到它们。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMUFAO.md.png" alt="EMUFAO.md.png"></p><h3 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h3><p>在实际运用中，一般来说，都是随机选取K个样本点作为聚类中心而不是像上面那样选择非样本点。当然，K的值要小于m。</p><p>通常我们都期望随机选取的聚类中心具有比较好的性质</p><p><img src="https://s2.ax1x.com/2019/04/28/EMwxIK.png" alt="EMwxIK.png"></p><p>但人生不如意之事十之八九，有时候选择的聚类中心不理想</p><p><img src="https://s2.ax1x.com/2019/04/28/EM08Zq.png" alt="EM08Zq.png"></p><p>就会在训练的过程中，导致局部最优解，如下图中右下角那样的结果。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMwD58.png" alt="EMwD58.png"></p><p>解决这个问题的方法简单粗暴，就是多次随机初始化聚类中心，得到多个拟合结果，然后挑选出代价最小的分类方法    。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMBGXd.png" alt="EMBGXd.png"></p><h3 id="选取聚类数量"><a href="#选取聚类数量" class="headerlink" title="选取聚类数量"></a>选取聚类数量</h3><p>关于如何确定K值，是一个很难回答的问题，甚至可以说没有确切的答案。但通常我们会采用以下的方法来帮助确定K的大小。</p><ul><li>肘部法则（<strong>Elbow method</strong>）</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EM2vX8.png" alt="EM2vX8.png"></p><p>但有些时候，得到的图像看起来像是连续的，不容易判断“肘部“位置。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMRn74.png" alt="EMRn74.png"></p><p>所以这个方法没办法适用于所有情况，所以通常推荐的方法是：根据你聚类的目的来确定K的数目（感觉是废话）。</p><h2 id="降维-Dimensionality-Reduction"><a href="#降维-Dimensionality-Reduction" class="headerlink" title="降维(Dimensionality Reduction)"></a>降维(Dimensionality Reduction)</h2><p>除了聚类之外，还有另一种无监督学习算法，叫做降维。</p><h3 id="目标I-数据压缩"><a href="#目标I-数据压缩" class="headerlink" title="目标I:数据压缩"></a>目标I:数据压缩</h3><p>降维的作用是消除特征冗余，如下图所示，特征$x_{1}$代表cm而特征$x_{2}$代表inches，含义相同，在图像上呈现出线性关系，完全可以只用一个特征来表示。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMfnY9.png" alt="EMfnY9.png"></p><p>更一般的，我们可以把两个冗余的特征用一个新的特征来表示，记为$z_{1}$，如下图。从另一个角度来看，也可以认为是把所有数据投影到了绿色的那条线上。</p><p><img src="https://s2.ax1x.com/2019/04/28/EMfs0S.png" alt="EMfs0S.png"></p><p>当然，很多时候冗余的特征不只两个，但原理是一样的，比如以3维为例：</p><p><img src="https://s2.ax1x.com/2019/04/28/EMfo0U.png" alt="EMfo0U.png"></p><h3 id="目标II：可视化"><a href="#目标II：可视化" class="headerlink" title="目标II：可视化"></a>目标II：可视化</h3><p>特征很多的情况下没办法直接可视化。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQYCZT.png" alt="EQYCZT.png"></p><p>这时候需要用到降维。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQYBFg.png" alt="EQYBFg.png"></p><p>降维之后的特征可能不具有物理意义，但方便画图。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQY7lR.png" alt="EQY7lR.png"></p><h3 id="主成分分析问题规划I"><a href="#主成分分析问题规划I" class="headerlink" title="主成分分析问题规划I"></a>主成分分析问题规划I</h3><p>主成分分析问题规划（<strong>Principle Component Analysis</strong>），是目前最流行的降维算法。举个例子简单说明原理：</p><p><img src="https://s2.ax1x.com/2019/04/28/EQavDI.png" alt="EQavDI.png"></p><p>图为从2维降到1维，PCA要求样本到投影点的距离的（投影误差）平方和最小。</p><p>更一般的情况，从n-D投影到k-D，也就是找到k个向量$u^{(1)},u^{(2)},…,u^{(3)}$作为被投影的线性子空间。再用3D投影到2D为例，记住PCA关键是投影误差要最小</p><p><img src="https://s2.ax1x.com/2019/04/28/EQWAYj.png" alt="EQWAYj.png"></p><ul><li>PCA和线性回归的区别</li></ul><p>二者毫无联系，虽然有时看上去图像是一样的，但线性回归时预测输出变量，它的代价函数表示的是拟合模型的输出误差，如图左；PCA的代价函数则是投影误差，如图右。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQW73n.png" alt="EQW73n.png"></p><h3 id="主成分分析问题规划II"><a href="#主成分分析问题规划II" class="headerlink" title="主成分分析问题规划II"></a>主成分分析问题规划II</h3><ul><li>特征缩放和均值归一化</li></ul><p><img src="https://s2.ax1x.com/2019/04/29/ElGKMt.png" alt="ElGKMt.png"></p><ul><li>求出$u^{(i)}$</li></ul><p>把数据从n维降到k维。</p><p>计算协方差矩阵：</p><p><img src="https://s2.ax1x.com/2019/04/29/ElGIoD.png" alt="ElGIoD.png"></p><p>其中$x^{(i)}$是nx1维，所以$\Sigma$是nxn维。写成向量形式：$\Sigma=1 / m\left(X^{T} X\right)$</p><p>再用svd对协方差矩阵进行奇异值分解：</p><p><img src="https://s2.ax1x.com/2019/04/29/ElGHWd.png" alt="ElGHWd.png"></p><p>最后我们需要的是U矩阵（nxn），取它的k个列向量构成矩阵z，再乘上$x^{(i)}$就可以得到$z^{(i)}$。</p><p><img src="https://s2.ax1x.com/2019/04/29/ElGvef.png" alt="ElGvef.png"></p><h3 id="主成分数量选择"><a href="#主成分数量选择" class="headerlink" title="主成分数量选择"></a>主成分数量选择</h3><p>之前提到过如何选择压缩后的维度k是很困难的，但在PCA中有一种很实用的方法，这一节展开说说。</p><p>通常来说，选择的k要让平均投影误差/数据总方差小于0.01，这种情况也称为“99%的方差被保留”，这句话代表了投影降维后的效果好。</p><p><img src="https://s2.ax1x.com/2019/04/29/ElwiUP.png" alt="ElwiUP.png"></p><p>从上面的公式可以看出，如果需要选择出合适的K，我们可以尝试不同的K值，直到找到能让公式小于0.01为止。</p><p><img src="https://s2.ax1x.com/2019/04/29/El07Y6.png" alt="El07Y6.png"></p><p>但这种方法显然效率不高，因此最好使用另一种方法。</p><p>之前提到的奇异值分解：$[U,S,V]=svd(Sigma)$，其中的矩阵S是一个对角矩阵，如下图所示，取主对角线中的k个值，满足$1-\frac{\sum_{i=1}^{k} S_{i i} }{\sum_{i=1}^{k} S_{ii} } \leqslant 0.01$即可。</p><p><img src="https://s2.ax1x.com/2019/04/29/El0XOH.png" alt="El0XOH.png"></p><h3 id="压缩重现"><a href="#压缩重现" class="headerlink" title="压缩重现"></a>压缩重现</h3><p>如果能从n维降至k维，同理也就能从k维升至n维。只需要把$z^{(i)}$代入$X_{appox} $=$ U_{radue} \cdot z^{(i)}$。就能求出x近似值。</p><p><img src="https://s2.ax1x.com/2019/04/29/ElDQUI.png" alt="ElDQUI.png"></p><h3 id="应用PCA的建议"><a href="#应用PCA的建议" class="headerlink" title="应用PCA的建议"></a>应用PCA的建议</h3><p>PCA也可以应用在监督学习算法中，只需要将$x^{(i)}$提取出来即可。另外必须要注意的是，把$x^{(i)}$映射到$z^{(i)}$（即求出U）的过程中只能在训练集中运行。</p><p><img src="https://s2.ax1x.com/2019/04/29/Elsvgf.png" alt="Elsvgf.png"></p><ul><li>PCA的应用</li></ul><p>（1）压缩数据，加快算法运行效率</p><p>（2）可视化：没得办法，我们只能可视化K&lt;3的数据</p><p>（3）不要用PCA来防止过拟合，因为PCA不使用标签y，这可能会导致信息的丢失。用正则化就行了，不要皮。</p><p>（4）在使用PCA之前，应该先考虑清楚是否真的有必要使用它，直接用原始数据也许就能得出想要的答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;无监督学习&quot;&gt;&lt;a href=&quot;#无监督学习&quot; class=&quot;headerlink&quot; title=&quot;无监督学习&quot;&gt;&lt;/a&gt;无监督学习&lt;/h2&gt;&lt;h3 id=&quot;无监督学习-1&quot;&gt;&lt;a href=&quot;#无监督学习-1&quot; class=&quot;headerlink&quot; title=&quot;无监督学习&quot;&gt;&lt;/a&gt;无监督学习&lt;/h3&gt;&lt;p&gt;之间学习的都是监督学习，也就是样本都有标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/04/28/EMlktI.png&quot; alt=&quot;EMlktI.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
</feed>
